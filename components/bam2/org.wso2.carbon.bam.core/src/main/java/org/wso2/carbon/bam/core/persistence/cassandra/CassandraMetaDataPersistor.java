/**
 * Copyright (c) 2009, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.wso2.carbon.bam.core.persistence.cassandra;

import org.apache.axis2.jaxws.description.xml.handler.PersistenceContextRefType;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.wso2.carbon.bam.core.configurations.AbstractMetaDataPersistor;
import org.wso2.carbon.bam.core.configurations.DataSourceType;
import org.wso2.carbon.bam.core.configurations.Granularity;
import org.wso2.carbon.bam.core.configurations.IndexConfiguration;
import org.wso2.carbon.bam.core.configurations.TableConfiguration;
import org.wso2.carbon.bam.core.dataobjects.Record;
import org.wso2.carbon.bam.core.internal.ServiceHolder;
import org.wso2.carbon.bam.core.persistence.PersistenceManager;
import org.wso2.carbon.bam.core.persistence.PersistencyConstants;
import org.wso2.carbon.bam.core.persistence.QueryIndex;
import org.wso2.carbon.bam.core.persistence.QueryManager;
import org.wso2.carbon.bam.core.persistence.exceptions.ConfigurationException;
import org.wso2.carbon.bam.core.persistence.exceptions.StoreException;
import org.wso2.carbon.registry.api.RegistryException;
import org.wso2.carbon.registry.core.Collection;
import org.wso2.carbon.registry.core.Resource;
import org.wso2.carbon.registry.core.session.UserRegistry;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

// TODO : Introduce transactions for registry operations
public class CassandraMetaDataPersistor extends AbstractMetaDataPersistor {

    private static final Log log = LogFactory.getLog(CassandraMetaDataPersistor.class);

/*    @Override
    public void persistIndex(int tenantId, IndexConfiguration configuration)
            throws ConfigurationException {
        // Load tenant registry to ensure the mounts are created before getting the tenant registry
        ServiceHolder.getTenantRegistryLoader().loadTenantRegistry(tenantId);

        try {
            // Get the config registry of the tenant
            UserRegistry tenantConfigSystemRegistry = ServiceHolder.getRegistryService().
                    getConfigSystemRegistry(tenantId);

            initializeCollections(tenantConfigSystemRegistry);

            CassandraIndexConfiguration cassandraIndexConfiguration =
                    (CassandraIndexConfiguration) configuration;
            String indexName = cassandraIndexConfiguration.getIndexName();

            Resource indexConfigurationResource = tenantConfigSystemRegistry.newResource();
            String indexConfigurationRootPath = PersistencyConstants.COMPONENT_ROOT +
                                                getIndexRegistryPath() + indexName;

            tenantConfigSystemRegistry.put(indexConfigurationRootPath, indexConfigurationResource);

            indexConfigurationResource = tenantConfigSystemRegistry.
                    get(indexConfigurationRootPath);
            indexConfigurationResource.setProperty(PersistencyConstants.NAME, indexName);
            indexConfigurationResource.setProperty(PersistencyConstants.INDEXED_TABLE,
                                                   cassandraIndexConfiguration.getIndexedTable());
            indexConfigurationResource.setProperty(PersistencyConstants.INDEX_TYPE,
                                                   cassandraIndexConfiguration.getIndexType().
                                                           getName());
            indexConfigurationResource.setProperty(PersistencyConstants.INDEXING_TABLE,
                                                   cassandraIndexConfiguration.
                                                           getIndexingColumnFamily());
            indexConfigurationResource.setProperty(PersistencyConstants.IS_AUTO_GENERATED,
                                                   Boolean.valueOf(cassandraIndexConfiguration.
                                                           isAutoGenerated()).toString());
            indexConfigurationResource.setProperty(PersistencyConstants.IS_MANUALLY_INDEXED,
                                                   Boolean.valueOf(cassandraIndexConfiguration.
                                                           isManuallyIndexed()).toString());
            indexConfigurationResource.setProperty(PersistencyConstants.DATASOURCE_TYPE,
                                                   cassandraIndexConfiguration.getDataSourceType().
                                                           getName());
            indexConfigurationResource.setProperty(PersistencyConstants.CRON,
                                                   cassandraIndexConfiguration.getCron());

            String[] indexedColumns = cassandraIndexConfiguration.getIndexedColumns();

            List<String> columnList = new ArrayList<String>();
            for (String indexedColumn : indexedColumns) {
                columnList.add(indexedColumn);
            }

            indexConfigurationResource.setProperty(PersistencyConstants.INDEXED_COLUMNS,
                                                   columnList);

            if (cassandraIndexConfiguration.getGranularity() != null) {
                indexConfigurationResource.setProperty(PersistencyConstants.GRANULARITY,
                                                       cassandraIndexConfiguration.getGranularity().
                                                               getName());
            }

            tenantConfigSystemRegistry.put(indexConfigurationRootPath, indexConfigurationResource);

        } catch (RegistryException e) {
            //rollback
            throw new ConfigurationException("Unable to store index configuration for index " +
                                             configuration.getIndexName() + "..", e);
        }
    }*/

    @Override
    public void persistIndex(Map<String, String> credentials, IndexConfiguration configuration)
            throws ConfigurationException {

        CassandraIndexConfiguration cassandraIndexConfiguration =
                (CassandraIndexConfiguration) configuration;
        String indexName = cassandraIndexConfiguration.getIndexName();

        Record record = new Record(indexName, new HashMap<String, String>());

        record.addColumn(PersistencyConstants.NAME, indexName);
        record.addColumn(PersistencyConstants.INDEXED_TABLE, cassandraIndexConfiguration.
                getIndexedTable());
        record.addColumn(PersistencyConstants.INDEX_TYPE, cassandraIndexConfiguration.
                getIndexType().getName());
        record.addColumn(PersistencyConstants.INDEXING_TABLE, cassandraIndexConfiguration.
                getIndexingColumnFamily());
        record.addColumn(PersistencyConstants.IS_AUTO_GENERATED, Boolean.valueOf(
                cassandraIndexConfiguration.isAutoGenerated()).toString());
        record.addColumn(PersistencyConstants.IS_MANUALLY_INDEXED, Boolean.valueOf(
                cassandraIndexConfiguration.isManuallyIndexed()).toString());
        record.addColumn(PersistencyConstants.DATASOURCE_TYPE, cassandraIndexConfiguration.
                getDataSourceType().getName());
        record.addColumn(PersistencyConstants.CRON, cassandraIndexConfiguration.getCron());

        String[] indexedColumns = cassandraIndexConfiguration.getIndexedColumns();

        StringBuilder sb = new StringBuilder();
        for (String indexedColumn : indexedColumns) {
            sb.append(indexedColumn);
            sb.append(":");
        }

        sb.deleteCharAt(sb.length() - 1); // Remove trailing ':'

        record.addColumn(PersistencyConstants.INDEXED_COLUMNS, sb.toString());

        if (cassandraIndexConfiguration.getGranularity() != null) {
            record.addColumn(PersistencyConstants.GRANULARITY, cassandraIndexConfiguration.
                    getGranularity().getName());
        }

        PersistenceManager persistenceManager = new PersistenceManager();

        try {
            persistenceManager.storeRecord(credentials, PersistencyConstants.INDEX_INFO_TABLE, record);
        } catch (StoreException e) {
            throw new ConfigurationException("Unable to store index configuration for index " +
                                             configuration.getIndexName() + "..", e);
        }

    }

/*    @Override
    public void persistTableMetaData(int tenantId, TableConfiguration configuration)
            throws ConfigurationException {
        // Load tenant registry to ensure the mounts are created before getting the tenant registry
        ServiceHolder.getTenantRegistryLoader().loadTenantRegistry(tenantId);

        try {
            // Get the config registry of the tenant
            UserRegistry tenantConfigSystemRegistry = ServiceHolder.getRegistryService().
                    getConfigSystemRegistry(tenantId);

            initializeCollections(tenantConfigSystemRegistry);

            CassandraCFConfiguration cassandraCFConfiguration =
                    (CassandraCFConfiguration) configuration;
            String columnFamily = cassandraCFConfiguration.getTableName();

            String cfConfigurationResourcePath = PersistencyConstants.COMPONENT_ROOT +
                                                 getTableRegistryPath() + columnFamily;

            Resource cfConfigurationResource = tenantConfigSystemRegistry.newResource();
            tenantConfigSystemRegistry.put(cfConfigurationResourcePath, cfConfigurationResource);

            cfConfigurationResource = tenantConfigSystemRegistry.
                    get(cfConfigurationResourcePath);
            cfConfigurationResource.setProperty(PersistencyConstants.NAME, columnFamily);
            cfConfigurationResource.setProperty(PersistencyConstants.DATASOURCE_TYPE,
                                                cassandraCFConfiguration.getDataSourceType()
                                                        .getName());
            cfConfigurationResource.setProperty(PersistencyConstants.SECONDARY_COLUMN_FAMILIES,
                                                cassandraCFConfiguration.
                                                        getSecondaryTables());
            cfConfigurationResource.setProperty(PersistencyConstants.IS_PRIMARY_CF,
                                                Boolean.valueOf(cassandraCFConfiguration.
                                                        isPrimaryTable()).toString());
            cfConfigurationResource.setProperty(PersistencyConstants.IS_AUTO_GENERATED,
                                                Boolean.valueOf(cassandraCFConfiguration.
                                                        getAutoGenerated()).toString());

            if (cassandraCFConfiguration.getColumns() != null) {
                cfConfigurationResource.setProperty(PersistencyConstants.COLUMNS,
                                                    cassandraCFConfiguration.getColumns());
            }

            tenantConfigSystemRegistry.put(cfConfigurationResourcePath, cfConfigurationResource);

        } catch (RegistryException e) {
            //rollback
            throw new ConfigurationException("Unable to store column family configuration for " +
                                             "column family " + configuration.getTableName() + "..",
                                             e);
        }
    }*/

    @Override
    public void persistTableMetaData(Map<String, String> credentials,
                                     TableConfiguration configuration)
            throws ConfigurationException {
        CassandraCFConfiguration cassandraCFConfiguration =
                (CassandraCFConfiguration) configuration;
        String columnFamily = cassandraCFConfiguration.getTableName();

        Record record = new Record(columnFamily, new HashMap<String, String>());

        record.addColumn(PersistencyConstants.NAME, columnFamily);
        record.addColumn(PersistencyConstants.DATASOURCE_TYPE, cassandraCFConfiguration.
                getDataSourceType().getName());

        List<String> secondaryTables = cassandraCFConfiguration.getSecondaryTables();

        StringBuffer sb = new StringBuffer();
        if (secondaryTables != null && secondaryTables.size() > 0) {
            for (String secondaryTable : secondaryTables) {
                sb.append(secondaryTable);
                sb.append(":");
            }

            sb.deleteCharAt(sb.length() - 1); // Remove trailing ':'
        }

        String secondaryList = sb.toString();
        record.addColumn(PersistencyConstants.SECONDARY_COLUMN_FAMILIES, secondaryList);

        record.addColumn(PersistencyConstants.IS_PRIMARY_CF, Boolean.valueOf(
                cassandraCFConfiguration.isPrimaryTable()).toString());
        record.addColumn(PersistencyConstants.IS_AUTO_GENERATED, Boolean.valueOf(
                cassandraCFConfiguration.getAutoGenerated()).toString());

        List<String> columns = cassandraCFConfiguration.getColumns();

        StringBuffer columnsSb = new StringBuffer();
        if (columns != null && columns.size() > 0) {
            for (String column : columns) {
                columnsSb.append(column);
                columnsSb.append(":");
            }

            columnsSb.deleteCharAt(columnsSb.length() - 1); // Remove trailing ':'
        }

        String columnList = columnsSb.toString();
        record.addColumn(PersistencyConstants.COLUMNS, columnList);

        PersistenceManager persistenceManager = new PersistenceManager();

        try {
            persistenceManager.storeRecord(credentials, PersistencyConstants.TABLE_INFO_TABLE, record);
        } catch (StoreException e) {
            throw new ConfigurationException("Unable to store column family configuration for " +
                                             "column family " + configuration.getTableName() + "..",
                                             e);
        }

    }
    
    public static Map<String, String> getTableMetaDataAsMap(TableConfiguration configuration) {
        
        CassandraCFConfiguration cassandraCFConfiguration =
                (CassandraCFConfiguration) configuration;
        String columnFamily = cassandraCFConfiguration.getTableName();

        Record record = new Record(columnFamily, new HashMap<String, String>());

        record.addColumn(PersistencyConstants.NAME, columnFamily);
        record.addColumn(PersistencyConstants.DATASOURCE_TYPE, cassandraCFConfiguration.
                getDataSourceType().getName());

        List<String> secondaryTables = cassandraCFConfiguration.getSecondaryTables();

        StringBuffer sb = new StringBuffer();
        if (secondaryTables != null && secondaryTables.size() > 0) {
            for (String secondaryTable : secondaryTables) {
                sb.append(secondaryTable);
                sb.append(":");
            }

            sb.deleteCharAt(sb.length() - 1); // Remove trailing ':'
        }

        String secondaryList = sb.toString();
        record.addColumn(PersistencyConstants.SECONDARY_COLUMN_FAMILIES, secondaryList);

        record.addColumn(PersistencyConstants.IS_PRIMARY_CF, Boolean.valueOf(
                cassandraCFConfiguration.isPrimaryTable()).toString());
        record.addColumn(PersistencyConstants.IS_AUTO_GENERATED, Boolean.valueOf(
                cassandraCFConfiguration.getAutoGenerated()).toString());

        List<String> columns = cassandraCFConfiguration.getColumns();

        StringBuffer columnsSb = new StringBuffer();
        if (columns != null && columns.size() > 0) {
            for (String column : columns) {
                columnsSb.append(column);
                columnsSb.append(":");
            }

            columnsSb.deleteCharAt(columnsSb.length() - 1); // Remove trailing ':'
        }

        String columnList = columnsSb.toString();
        record.addColumn(PersistencyConstants.COLUMNS, columnList); 
        
        return record.getColumns();
        
    }

/*    @Override
    public List<IndexConfiguration> getAllIndexMetaData(int tenantId)
            throws ConfigurationException {
        // Load tenant registry to ensure the mounts are created before getting the tenant registry
        ServiceHolder.getTenantRegistryLoader().loadTenantRegistry(tenantId);

        List<IndexConfiguration> indexConfigurations = new ArrayList<IndexConfiguration>();
        try {
            // Get the config registry of the tenant
            UserRegistry tenantConfigSystemRegistry = ServiceHolder.getRegistryService().
                    getConfigSystemRegistry(tenantId);

            String indexConfigurationRootPath = PersistencyConstants.COMPONENT_ROOT +
                                                getIndexRegistryPath();

            if (tenantConfigSystemRegistry.resourceExists(indexConfigurationRootPath)) {
                Resource indexConfigurationRootResource = tenantConfigSystemRegistry.
                        get(indexConfigurationRootPath);
                Collection indexConfigurationRootCollection = (Collection)
                        indexConfigurationRootResource;

                String[] indexConfigurationResourcePaths = indexConfigurationRootCollection.
                        getChildren();
                for (String indexConfigurationResourcePath : indexConfigurationResourcePaths) {
                    Resource indexConfigurationResource = tenantConfigSystemRegistry.
                            get(indexConfigurationResourcePath);
                    String indexName = indexConfigurationResource.
                            getProperty(PersistencyConstants.NAME);
                    String indexedTable = indexConfigurationResource.getProperty(
                            PersistencyConstants.INDEXED_TABLE);
                    String indexingTable = indexConfigurationResource.getProperty(
                            PersistencyConstants.INDEXING_TABLE);
                    String granularity = indexConfigurationResource.getProperty(
                            PersistencyConstants.GRANULARITY);
                    List<String> columns = indexConfigurationResource.getPropertyValues(
                            PersistencyConstants.INDEXED_COLUMNS);
                    String isAutoGenerated = indexConfigurationResource.getProperty(
                            PersistencyConstants.IS_AUTO_GENERATED);
                    String isManuallyIndexed = indexConfigurationResource.getProperty(
                            PersistencyConstants.IS_MANUALLY_INDEXED);
                    String dataSourceTypeStr = indexConfigurationResource.getProperty(
                            PersistencyConstants.DATASOURCE_TYPE);
                    String cron = indexConfigurationResource.getProperty(PersistencyConstants.CRON);
                    DataSourceType dataSourceType = DataSourceType.valueOf(dataSourceTypeStr);

                    CassandraIndexConfiguration indexConfiguration = new CassandraIndexConfiguration
                            (indexName, indexedTable, columns.toArray(new String[]{}),
                             dataSourceType);
                    indexConfiguration.setIndexingColumnFamily(indexingTable);
                    indexConfiguration.setAutoGenerated(Boolean.parseBoolean(isAutoGenerated));
                    indexConfiguration.setManuallyIndexed(Boolean.parseBoolean(isManuallyIndexed));
                    indexConfiguration.setCron(cron);

                    if (granularity != null) {
                        indexConfiguration.setGranularity(Granularity.valueOf(
                                granularity.toUpperCase()));
                    }

                    indexConfigurations.add(indexConfiguration);
                }
            }

        } catch (RegistryException e) {
            //rollback
            throw new ConfigurationException("Unable to fetch index configurations..", e);
        }

        return indexConfigurations;

    }*/

    @Override
    public List<IndexConfiguration> getAllIndexMetaData(Map<String, String> credentials)
            throws ConfigurationException {
        QueryManager queryManager = new QueryManager();

        List<IndexConfiguration> indexConfigurations = new ArrayList<IndexConfiguration>();
        try {
            List<Record> records = queryManager.getRecords(
                    credentials, PersistencyConstants.INDEX_INFO_TABLE, (QueryIndex) null, null);

            if (records != null) {
                for (Record record : records) {
                    String indexName = record.getKey();

                    Map<String, String> columns = (Map<String, String>) record.getColumns();

                    if (columns != null && columns.size() > 0) {

                        String indexedTable = columns.get(PersistencyConstants.INDEXED_TABLE);
                        String indexingTable = columns.get(PersistencyConstants.INDEXING_TABLE);
                        String granularity = columns.get(PersistencyConstants.GRANULARITY);

                        String columnList = columns.get(PersistencyConstants.INDEXED_COLUMNS);
                        String[] indexedColumns = columnList.split(":");

                        String isManuallyIndexed = columns.get(
                                PersistencyConstants.IS_MANUALLY_INDEXED);
                        String isAutoGenerated = columns.get(
                                PersistencyConstants.IS_AUTO_GENERATED);
                        String dataSourceTypeStr = columns.get(
                                PersistencyConstants.DATASOURCE_TYPE);
                        String cron = columns.get(PersistencyConstants.CRON);
                        DataSourceType dataSourceType = DataSourceType.valueOf(dataSourceTypeStr);

                        CassandraIndexConfiguration indexConfiguration = new CassandraIndexConfiguration
                                (indexName, indexedTable, indexedColumns, dataSourceType);
                        indexConfiguration.setIndexingColumnFamily(indexingTable);
                        indexConfiguration.setAutoGenerated(Boolean.parseBoolean(isAutoGenerated));
                        indexConfiguration.setManuallyIndexed(Boolean.parseBoolean(
                                isManuallyIndexed));
                        indexConfiguration.setCron(cron);

                        if (granularity != null) {
                            indexConfiguration.setGranularity(Granularity.valueOf(
                                    granularity.toUpperCase()));
                        }

                        indexConfigurations.add(indexConfiguration);

                    }
                }
            }
        } catch (StoreException e) {
            throw new ConfigurationException("Unable to fetch index configurations..", e);
        }

        return indexConfigurations;

    }

/*    @Override
    public IndexConfiguration getIndexMetaData(int tenantId, String indexName)
            throws ConfigurationException {
        // Load tenant registry to ensure the mounts are created before getting the tenant registry
        ServiceHolder.getTenantRegistryLoader().loadTenantRegistry(tenantId);

        try {
            // Get the config registry of the tenant
            UserRegistry tenantConfigSystemRegistry = ServiceHolder.getRegistryService().
                    getConfigSystemRegistry(tenantId);

            String indexConfigurationPath = PersistencyConstants.COMPONENT_ROOT +
                                            getIndexRegistryPath() + indexName;

            if (tenantConfigSystemRegistry.resourceExists(indexConfigurationPath)) {
                Resource indexConfigurationResource = tenantConfigSystemRegistry.
                        get(indexConfigurationPath);

                String indexedTable = indexConfigurationResource.getProperty(
                        PersistencyConstants.INDEXED_TABLE);
                String indexingTable = indexConfigurationResource.getProperty(
                        PersistencyConstants.INDEXING_TABLE);
                String granularity = indexConfigurationResource.getProperty(
                        PersistencyConstants.GRANULARITY);
                List<String> columns = indexConfigurationResource.getPropertyValues(
                        PersistencyConstants.INDEXED_COLUMNS);
                String isAutoGenerated = indexConfigurationResource.getProperty(
                        PersistencyConstants.IS_AUTO_GENERATED);
                String isManuallyIndexed = indexConfigurationResource.getProperty(
                        PersistencyConstants.IS_MANUALLY_INDEXED);
                String dataSourceTypeStr = indexConfigurationResource.getProperty(
                        PersistencyConstants.DATASOURCE_TYPE);
                String cron = indexConfigurationResource.getProperty(PersistencyConstants.CRON);

                DataSourceType dataSourceType = DataSourceType.valueOf(dataSourceTypeStr);

                CassandraIndexConfiguration indexConfiguration = new CassandraIndexConfiguration
                        (indexName, indexedTable, columns.toArray(new String[]{}), dataSourceType);
                indexConfiguration.setIndexingColumnFamily(indexingTable);
                indexConfiguration.setGranularity(Granularity.valueOf(granularity));
                indexConfiguration.setAutoGenerated(Boolean.parseBoolean(isAutoGenerated));
                indexConfiguration.setManuallyIndexed(Boolean.parseBoolean(isManuallyIndexed));
                indexConfiguration.setCron(cron);

                return indexConfiguration;

            }

        } catch (RegistryException e) {
            //rollback
            throw new ConfigurationException("Unable to fetch the configuration for index " +
                                             indexName + "..", e);
        }

        return null;

    }*/

    @Override
    public IndexConfiguration getIndexMetaData(Map<String, String> credentials, String indexName)
            throws ConfigurationException {
        QueryManager queryManager = new QueryManager();

        CassandraIndexConfiguration indexConfiguration = null;
        try {
            List<Record> records = queryManager.getRecords(
                    credentials, PersistencyConstants.INDEX_INFO_TABLE, indexName, null);

            if (records != null) {

                Record record = records.get(0); // There is only one record per index

                Map<String, String> columns = (Map<String, String>) record.getColumns();

                if (columns != null) {

                    String indexedTable = columns.get(PersistencyConstants.INDEXED_TABLE);
                    String indexingTable = columns.get(PersistencyConstants.INDEXING_TABLE);
                    String granularity = columns.get(PersistencyConstants.GRANULARITY);

                    String columnList = columns.get(PersistencyConstants.INDEXED_COLUMNS);
                    String[] indexedColumns = columnList.split(":");

                    String isManuallyIndexed = columns.get(
                            PersistencyConstants.IS_MANUALLY_INDEXED);
                    String isAutoGenerated = columns.get(
                            PersistencyConstants.IS_AUTO_GENERATED);
                    String dataSourceTypeStr = columns.get(
                            PersistencyConstants.DATASOURCE_TYPE);
                    String cron = columns.get(PersistencyConstants.CRON);
                    DataSourceType dataSourceType = DataSourceType.valueOf(dataSourceTypeStr);

                    indexConfiguration = new CassandraIndexConfiguration
                            (indexName, indexedTable, indexedColumns, dataSourceType);
                    indexConfiguration.setIndexingColumnFamily(indexingTable);
                    indexConfiguration.setAutoGenerated(Boolean.parseBoolean(isAutoGenerated));
                    indexConfiguration.setManuallyIndexed(Boolean.parseBoolean(
                            isManuallyIndexed));
                    indexConfiguration.setCron(cron);

                    if (granularity != null) {
                        indexConfiguration.setGranularity(Granularity.valueOf(
                                granularity.toUpperCase()));
                    }

                }
            }
        } catch (StoreException e) {
            throw new ConfigurationException("Unable to fetch the configuration for index " +
                                             indexName + "..", e);
        }

        return indexConfiguration;

    }

/*    @Override
    public List<TableConfiguration> getAllTableMetaData(int tenantId)
            throws ConfigurationException {
        // Load tenant registry to ensure the mounts are created before getting the tenant registry
        ServiceHolder.getTenantRegistryLoader().loadTenantRegistry(tenantId);

        List<TableConfiguration> cfConfigurations = new ArrayList<TableConfiguration>();
        try {
            // Get the config registry of the tenant
            UserRegistry tenantConfigSystemRegistry = ServiceHolder.getRegistryService().
                    getConfigSystemRegistry(tenantId);

            String cfConfigurationRootPath = PersistencyConstants.COMPONENT_ROOT +
                                             getTableRegistryPath();

            if (tenantConfigSystemRegistry.resourceExists(cfConfigurationRootPath)) {
                Resource cfConfigurationRootResource = tenantConfigSystemRegistry.
                        get(cfConfigurationRootPath);
                Collection cfConfigurationRootCollection = (Collection)
                        cfConfigurationRootResource;

                String[] cfConfigurationResourcePaths = cfConfigurationRootCollection.
                        getChildren();
                for (String cfConfigurationResourcePath : cfConfigurationResourcePaths) {
                    Resource cfConfigurationResource = tenantConfigSystemRegistry.
                            get(cfConfigurationResourcePath);

                    String columnFamily = cfConfigurationResource.getProperty(
                            PersistencyConstants.NAME);
                    String dataSourceType = cfConfigurationResource.getProperty(
                            PersistencyConstants.DATASOURCE_TYPE);
                    List<String> secondaryCfs = cfConfigurationResource.getPropertyValues(
                            PersistencyConstants.SECONDARY_COLUMN_FAMILIES);
                    List<String> columns = cfConfigurationResource.getPropertyValues(
                            PersistencyConstants.COLUMNS);
                    String isPrimaryCf = cfConfigurationResource.getProperty(
                            PersistencyConstants.IS_PRIMARY_CF);
                    String autoGenerated = cfConfigurationResource.getProperty(
                            PersistencyConstants.IS_AUTO_GENERATED);

                    CassandraCFConfiguration cassandraCFConfiguration =
                            new CassandraCFConfiguration(columnFamily, columns,
                                                         DataSourceType.valueOf(dataSourceType));
                    cassandraCFConfiguration.setPrimaryTable(
                            Boolean.parseBoolean(isPrimaryCf));
                    cassandraCFConfiguration.setAutoGenerated(Boolean.parseBoolean(autoGenerated));
                    cassandraCFConfiguration.setSecondaryTables(secondaryCfs);

                    cfConfigurations.add(cassandraCFConfiguration);
                }
            }
        } catch (RegistryException e) {
            throw new ConfigurationException("Unable to fetch column family configurations..", e);
        }

        return cfConfigurations;

    }*/

    @Override
    public List<TableConfiguration> getAllTableMetaData(Map<String, String> credentials)
            throws ConfigurationException {

        QueryManager queryManager = new QueryManager();

        List<TableConfiguration> cfConfigurations = new ArrayList<TableConfiguration>();
        try {
            List<Record> records = queryManager.getRecords(
                    credentials, PersistencyConstants.TABLE_INFO_TABLE, (QueryIndex) null, null);

            if (records != null) {
                for (Record record : records) {
                    String columnFamily = record.getKey();

                    Map<String, String> columns = (Map<String, String>) record.getColumns();

                    // Check column size as well since Cassandra will return deleted row keys as well
                    // (range ghosts)
                    if (columns != null && columns.size() > 0) {
                        DataSourceType dataSourceType = DataSourceType.valueOf(columns.
                                get(PersistencyConstants.DATASOURCE_TYPE));
                        String columnList = columns.get(PersistencyConstants.COLUMNS);

                        List<String> cfColumns = new ArrayList<String>();
                        if (columnList != null) {
                            String[] columnTokens = columnList.split(":");

                            for (String columnToken : columnTokens) {
                                if (!"".equals(columnToken)) {
                                    cfColumns.add(columnToken);
                                }
                            }
                        }

                        CassandraCFConfiguration cfConfiguration = new CassandraCFConfiguration(
                                columnFamily, cfColumns, dataSourceType);

                        String secondaryTableList = columns.get(
                                PersistencyConstants.SECONDARY_COLUMN_FAMILIES);
                        List<String> secondaryTables = new ArrayList<String>();
                        if (secondaryTableList != null) {
                            String[] secondaryTableTokens = secondaryTableList.split(":");

                            for (String secondaryTableToken : secondaryTableTokens) {
                                if (!"".equals(secondaryTableToken)) {
                                    secondaryTables.add(secondaryTableToken);
                                }
                            }
                        }

                        cfConfiguration.setSecondaryTables(secondaryTables);

                        cfConfiguration.setAutoGenerated(Boolean.valueOf(
                                columns.get(PersistencyConstants.IS_AUTO_GENERATED)));
                        cfConfiguration.setPrimaryTable(Boolean.valueOf(
                                columns.get(PersistencyConstants.IS_PRIMARY_CF)));

                        cfConfigurations.add(cfConfiguration);

                    }
                }
            }
        } catch (StoreException e) {
            throw new ConfigurationException("Unable to fetch column family configurations..", e);
        }

        return cfConfigurations;

    }

/*    @Override
    public TableConfiguration getTableMetaData(int tenantId, String columnFamily)
            throws ConfigurationException {
        // Load tenant registry to ensure the mounts are created before getting the tenant registry
        ServiceHolder.getTenantRegistryLoader().loadTenantRegistry(tenantId);

        try {
            // Get the config registry of the tenant
            UserRegistry tenantConfigSystemRegistry = ServiceHolder.getRegistryService().
                    getConfigSystemRegistry(tenantId);

            String cfConfigurationResourcePath = PersistencyConstants.COMPONENT_ROOT +
                                                 getTableRegistryPath() + columnFamily;

            if (tenantConfigSystemRegistry.resourceExists(cfConfigurationResourcePath)) {
                Resource cfConfigurationResource = tenantConfigSystemRegistry.
                        get(cfConfigurationResourcePath);

                String dataSourceType = cfConfigurationResource.getProperty(
                        PersistencyConstants.DATASOURCE_TYPE);
                List<String> secondaryCfs = cfConfigurationResource.getPropertyValues(
                        PersistencyConstants.SECONDARY_COLUMN_FAMILIES);
                List<String> columns = cfConfigurationResource.getPropertyValues(
                        PersistencyConstants.COLUMNS);
                String isPrimaryCf = cfConfigurationResource.getProperty(
                        PersistencyConstants.IS_PRIMARY_CF);
                String autoGenerated = cfConfigurationResource.getProperty(
                        PersistencyConstants.IS_AUTO_GENERATED);

                CassandraCFConfiguration cassandraCFConfiguration = new CassandraCFConfiguration(
                        columnFamily, columns, DataSourceType.valueOf(dataSourceType));
                cassandraCFConfiguration.setPrimaryTable(Boolean.parseBoolean(isPrimaryCf));
                cassandraCFConfiguration.setAutoGenerated(Boolean.parseBoolean(autoGenerated));
                cassandraCFConfiguration.setSecondaryTables(secondaryCfs);

                return cassandraCFConfiguration;
            }

        } catch (RegistryException e) {
            //rollback
            throw new ConfigurationException("Unable to fetch column family configuration for " +
                                             "column family " + columnFamily + "..",
                                             e);
        }

        return null;

    }*/

    @Override
    public TableConfiguration getTableMetaData(Map<String, String> credentials, String columnFamily)
            throws ConfigurationException {
        QueryManager queryManager = new QueryManager();

        CassandraCFConfiguration cfConfiguration = null;
        try {
            List<Record> records = queryManager.getRecords(
                    credentials, PersistencyConstants.TABLE_INFO_TABLE, columnFamily, null);

            if (records != null) {

                Record record = records.get(0); // There is only one record per column family

                Map<String, String> columns = (Map<String, String>) record.getColumns();

                if (columns != null) {
                    DataSourceType dataSourceType = DataSourceType.valueOf(columns.
                            get(PersistencyConstants.DATASOURCE_TYPE));
                    String columnList = columns.get(PersistencyConstants.COLUMNS);

                    List<String> cfColumns = new ArrayList<String>();
                    if (columnList != null) {
                        String[] columnTokens = columnList.split(":");

                        for (String columnToken : columnTokens) {
                            if (!"".equals(columnToken)) {
                                cfColumns.add(columnToken);
                            }
                        }
                    }

                    cfConfiguration = new CassandraCFConfiguration(
                            columnFamily, cfColumns, dataSourceType);

                    String secondaryTableList = columns.get(
                            PersistencyConstants.SECONDARY_COLUMN_FAMILIES);
                    List<String> secondaryTables = new ArrayList<String>();
                    if (secondaryTableList != null) {
                        String[] secondaryTableTokens = secondaryTableList.split(":");

                        for (String secondaryTableToken : secondaryTableTokens) {
                            if (!"".equals(secondaryTableToken)) {
                                secondaryTables.add(secondaryTableToken);
                            }
                        }
                    }

                    cfConfiguration.setSecondaryTables(secondaryTables);

                    cfConfiguration.setAutoGenerated(Boolean.valueOf(
                            columns.get(PersistencyConstants.IS_AUTO_GENERATED)));
                    cfConfiguration.setPrimaryTable(Boolean.valueOf(
                            columns.get(PersistencyConstants.IS_PRIMARY_CF)));


                }
            }
        } catch (StoreException e) {
            throw new ConfigurationException("Unable to fetch column family configuration for " +
                                             "column family " + columnFamily + "..",
                                             e);
        }

        return cfConfiguration;

    }


}

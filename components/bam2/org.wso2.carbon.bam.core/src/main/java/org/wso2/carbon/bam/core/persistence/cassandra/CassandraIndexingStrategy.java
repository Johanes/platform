/**
 * Copyright (c) 2009, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.wso2.carbon.bam.core.persistence.cassandra;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.wso2.carbon.bam.core.configurations.DataSourceType;
import org.wso2.carbon.bam.core.configurations.Granularity;
import org.wso2.carbon.bam.core.configurations.IndexConfiguration;
import org.wso2.carbon.bam.core.configurations.IndexingTaskConfiguration;
import org.wso2.carbon.bam.core.configurations.TableConfiguration;
import org.wso2.carbon.bam.core.dataobjects.Cursor;
import org.wso2.carbon.bam.core.dataobjects.Record;
import org.wso2.carbon.bam.core.persistence.IndexManager;
import org.wso2.carbon.bam.core.persistence.IndexingStrategy;
import org.wso2.carbon.bam.core.persistence.MetaDataManager;
import org.wso2.carbon.bam.core.persistence.PersistenceManager;
import org.wso2.carbon.bam.core.persistence.PersistencyConstants;
import org.wso2.carbon.bam.core.persistence.QueryManager;
import org.wso2.carbon.bam.core.persistence.exceptions.ConfigurationException;
import org.wso2.carbon.bam.core.persistence.exceptions.IndexingException;
import org.wso2.carbon.bam.core.persistence.exceptions.StoreException;
import org.wso2.carbon.bam.core.utils.TimeStampFactory;
import org.wso2.carbon.bam.core.utils.Utils;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class CassandraIndexingStrategy implements IndexingStrategy {

    private static final Log log = LogFactory.getLog(PersistenceManager.class);

    @Override
    public void createIndex(IndexConfiguration indexConfiguration, Map<String, String> credentials)
            throws IndexingException {
        try {
            PersistenceManager manager = new PersistenceManager();

            // Initialize the data store so that default column families are created if not already
            // so.
            manager.getDataStore(indexConfiguration.getDataSourceType(), credentials);

            int tenantId;
            try {
                tenantId = Utils.getTenantIdFromUserName(credentials.get(
                        PersistencyConstants.USER_NAME));
            } catch (StoreException e) {
                throw new IndexingException("Unable to create index " +
                                            indexConfiguration.getIndexName() + " ..", e);
            }

            if (!manager.isTableExists(credentials, indexConfiguration.getIndexedTable())) {
                TableConfiguration cfConfiguration = new CassandraCFConfiguration(
                        indexConfiguration.getIndexedTable(), null, DataSourceType.CASSANDRA);
                manager.createTable(credentials, cfConfiguration);
            }

            // If this index is auto generated it is not required to explicitly create indexing
            // column family or create a separate indexing task. Just store the meta data and return.
            if (indexConfiguration.isAutoGenerated()) {
                MetaDataManager metaDataManager = MetaDataManager.getInstance();
                metaDataManager.storeIndexMetaData(credentials, indexConfiguration);

                return;
            }

            CassandraCFConfiguration config = new CassandraCFConfiguration(
                    indexConfiguration.getIndexName() + "_Index_" +
                    indexConfiguration.getIndexedTable(),
                    null, DataSourceType.CASSANDRA);
            config.setPrimaryTable(Boolean.TRUE);
            config.setAutoGenerated(Boolean.TRUE);

            List<String> secondaryTables = new ArrayList<String>();
            if (indexConfiguration.getIndexedTable().equalsIgnoreCase(
                    PersistencyConstants.BASE_TABLES)) {
                secondaryTables.add(PersistencyConstants.EVENT_TABLE);
                secondaryTables.add(PersistencyConstants.META_TABLE);
                secondaryTables.add(PersistencyConstants.CORRELATION_TABLE);
            } else {
                secondaryTables.add(indexConfiguration.getIndexedTable());
            }

            config.setSecondaryTables(secondaryTables);

            manager.createTable(credentials, config);

            ((CassandraIndexConfiguration) indexConfiguration).setIndexingColumnFamily(
                    config.getTableName());

            indexConfiguration.setManuallyIndexed(Boolean.TRUE);

            MetaDataManager metaDataManager = MetaDataManager.getInstance();
            metaDataManager.storeIndexMetaData(credentials, indexConfiguration);

            IndexingTaskConfiguration taskConfiguration = new IndexingTaskConfiguration();
            taskConfiguration.setCredentials(credentials);
            taskConfiguration.setTenantId(tenantId);
            taskConfiguration.setTaskName(indexConfiguration.getIndexName() + "_Index_" +
                                          indexConfiguration.getIndexedTable());

            String cron = ((CassandraIndexConfiguration) indexConfiguration).getCron();

            if (cron != null && !"".equals(cron)) {
                taskConfiguration.setCron(cron);
            } else {
                taskConfiguration.setInterval(PersistencyConstants.DEFAULT_INDEXING_INTERVAL);
            }

            IndexManager.getInstance().scheduleIndexingTask(indexConfiguration, taskConfiguration);

        } catch (StoreException e) {
            throw new IndexingException("Unable to create index..", e);
        } catch (ConfigurationException e) {
            // roll back. Delete index column family..
            throw new IndexingException("Unable to create index..", e);
        } catch (IndexingException e) {
            // roll back. Delete index column family and index meta data..
            throw e;
        }
    }

    // For Cassandra case editing the index means changing the indexing frequency.
    @Override
    public void editIndex(IndexConfiguration configuration, Map<String, String> credentials)
            throws IndexingException {

        int tenantId;
        try {
            tenantId = Utils.getTenantIdFromUserName(
                    credentials.get(PersistencyConstants.USER_NAME));
        } catch (StoreException e) {
            throw new IndexingException("Unable to obtain tenant information", e);
        }

        String taskName = configuration.getIndexName() + "_Index_" +
                          configuration.getIndexedTable();

        IndexingTaskConfiguration taskConfiguration = new IndexingTaskConfiguration();
        taskConfiguration.setTaskName(taskName);
        taskConfiguration.setTenantId(tenantId);

        // Unschedule the current indexing task
        IndexManager.getInstance().unScheduleIndexingTask(taskConfiguration);

        // Reschedule with changed indexing interval
        taskConfiguration = new IndexingTaskConfiguration();
        taskConfiguration.setCredentials(credentials);
        taskConfiguration.setTenantId(tenantId);
        taskConfiguration.setTaskName(taskName);

        String cron = ((CassandraIndexConfiguration) configuration).getCron();

        if (cron != null) {
            taskConfiguration.setCron(cron);
        } else {
            taskConfiguration.setInterval(PersistencyConstants.DEFAULT_INDEXING_INTERVAL);
        }

        IndexManager.getInstance().scheduleIndexingTask(configuration, taskConfiguration);

    }

    @Override
    public void deleteIndex(String indexName, Map<String, String> credentials)
            throws IndexingException {

        if (!Utils.credentialsValid(credentials)) {
            if (log.isDebugEnabled()) {
                log.debug("Credentials invalid or not yet provided..");
            }
        }

        int tenantId;
        try {
            tenantId = Utils.getTenantIdFromUserName(
                    credentials.get(PersistencyConstants.USER_NAME));
        } catch (StoreException e) {
            throw new IndexingException("Unable to obtain tenant information", e);
        }

        MetaDataManager metaDataManager = MetaDataManager.getInstance();

        try {
            CassandraIndexConfiguration configuration = (CassandraIndexConfiguration)
                    metaDataManager.getIndexMetaData(credentials, indexName);
            String indexingColumnFamily = configuration.getIndexingColumnFamily();

            PersistenceManager persistenceManager = new PersistenceManager();
            persistenceManager.deleteTable(credentials, indexingColumnFamily);

            metaDataManager.deleteIndexMetaData(credentials, indexName);

            String taskName = configuration.getIndexName() + "_Index_" +
                              configuration.getIndexedTable();

            IndexingTaskConfiguration taskConfiguration = new IndexingTaskConfiguration();
            taskConfiguration.setTaskName(taskName);
            taskConfiguration.setTenantId(tenantId);

            IndexManager.getInstance().unScheduleIndexingTask(taskConfiguration);

        } catch (ConfigurationException e) {
            throw new IndexingException("Unable to delete index meta data..", e);
        } catch (StoreException e) {
            throw new IndexingException("Unable to delete indexing column family..", e);
        }


    }

    @Override
    public void indexData(IndexConfiguration configuration, Cursor cursor,
                          Map<String, String> credentials) throws IndexingException {
        CassandraIndexConfiguration config = (CassandraIndexConfiguration) configuration;
        String indexedCfName = config.getIndexedTable();
        String indexingCfName = config.getIndexingColumnFamily();

        QueryManager queryManager = new QueryManager();

        List<Record> recordsToBeIndexed;
        try {
            recordsToBeIndexed = queryManager.
                    getRecords(credentials, indexedCfName, null, null,
                               PersistencyConstants.DEFAULT_BATCH_SIZE, cursor);
        } catch (StoreException e) {
            throw new IndexingException("Error while indexing column family " + indexedCfName +
                                        " for index " + configuration.getIndexName() + "..",e);
        }

        List<Record> indexedRecords = new ArrayList<Record>();
        List<Record> indexRecords = new ArrayList<Record>();

        for (Record recordToBeIndexed : recordsToBeIndexed) {
            String rowKey = createRowKey(configuration.getIndexedColumns(),
                                         configuration.getGranularity(),
                                         recordToBeIndexed.getColumns());
            if (rowKey != null) {
                Map<String, String> columns = new HashMap<String, String>();
                columns.put(recordToBeIndexed.getKey(), "");

                Record<String> indexedRecord = new Record<String>(rowKey, columns);
                indexedRecords.add(indexedRecord);

                String[][] indexes = getIndexValueArrayOfRecord(indexedRecord, configuration);
                if (indexes != null) {
                    for (int i = 0; i < indexes.length; i++) {

                        String subIndexValue = indexes[i][1];

                        Map<String, String> column = new HashMap<String, String>();
                        column.put(subIndexValue, "");

                        String subIndexName = indexes[i][0];
                        String subIndexRecordKey = PersistencyConstants.INDEX +
                                                PersistencyConstants.INDEX_DELIMITER +
                                                config.getIndexName() +
                                                PersistencyConstants.INDEX_DELIMITER +
                                                PersistencyConstants.SUB_INDEX +
                                                PersistencyConstants.INDEX_DELIMITER + subIndexName;

                        Record subIndexValueRecord = new Record(subIndexRecordKey, column);

                        // Last sub index of the composite index doesn't have any child index values
                        if ((i + 1) != indexes.length) {

                            String nextSubIndexValuesRecordKey
                                    = PersistencyConstants.INDEX +
                                      PersistencyConstants.INDEX_DELIMITER +
                                      config.getIndexName() +
                                      PersistencyConstants.INDEX_DELIMITER +
                                      PersistencyConstants.SUB_INDEX +
                                      PersistencyConstants.INDEX_DELIMITER +
                                      subIndexName +
                                      PersistencyConstants.INDEX_DELIMITER +
                                      PersistencyConstants.SUB_INDEX_VALUE +
                                      PersistencyConstants.INDEX_DELIMITER +
                                      subIndexValue;


                            String nextSubIndexValue = indexes[i + 1][1];

                            Map<String, String> nexSubIndexValueColumn = new HashMap<String, String>();
                            nexSubIndexValueColumn.put(nextSubIndexValue, "");

                            Record nextSubIndexRecord = new Record(nextSubIndexValuesRecordKey,
                                                                    nexSubIndexValueColumn);

                            indexRecords.add(nextSubIndexRecord);

                        }

                        indexRecords.add(subIndexValueRecord);
                    }
                }
            }
        }

        PersistenceManager persistenceManager = new PersistenceManager();

        try {
            persistenceManager.storeRecords(credentials, indexingCfName, indexedRecords);
        } catch (StoreException e) {
            throw new IndexingException("Error while indexing column family " + indexedCfName +
                                        " for index " + configuration.getIndexName() + "..",e);
        }

        try {
            persistenceManager.storeRecords(credentials, PersistencyConstants.META_INFO_TABLE,
                                            indexRecords);
        } catch (StoreException e) {
            throw new IndexingException("Error while storing index value meta data for column " +
                                        "family " + indexedCfName + " for index " +
                                        configuration.getIndexName() + "..",e);
        }

    }

    @Override
    public Map<String, String> getIndexValuesOfRecord(Record record,
                                                      IndexConfiguration configuration) {
        String key = record.getKey();

        if (key != null) {
            String[] compositeValues = key.split(PersistencyConstants.INDEX_DELIMITER);

            Map<String, String> indexValues = new LinkedHashMap<String, String>();

            String[] columns = configuration.getIndexedColumns();

            for (int i = 0; i < compositeValues.length; i++) {
                String compositeValue = compositeValues[i];
                String compositeColumn = columns[i];

                indexValues.put(compositeColumn, compositeValue);
            }

            return indexValues;

        } else {
            return null;
        }
    }

    @Override
    public Map<String, List<String>> getIndexValues(String indexName,
                                                    Map<String, String> credentials)
            throws IndexingException {

        if (!Utils.credentialsValid(credentials)) {
            if (log.isDebugEnabled()) {
                log.debug("Credentials invalid or not yet provided..");
            }
        }

        MetaDataManager metaDataManager = MetaDataManager.getInstance();

        Map<String, List<String>> indexValues = new HashMap<String, List<String>>();
        try {
            CassandraIndexConfiguration configuration = (CassandraIndexConfiguration)
                    metaDataManager.getIndexMetaData(credentials, indexName);
            String indexingColumnFamily = configuration.getIndexingColumnFamily();
            String[] indexedColumns = configuration.getIndexedColumns();

            QueryManager queryManager = new QueryManager();

            try {
                for (String indexedColumn : indexedColumns) {
                    String indexValuesRowKey = PersistencyConstants.INDEX +
                                               PersistencyConstants.INDEX_DELIMITER +
                                               configuration.getIndexName() +
                                               PersistencyConstants.INDEX_DELIMITER +
                                               PersistencyConstants.SUB_INDEX +
                                               PersistencyConstants.INDEX_DELIMITER + indexedColumn;
                    List<Record> records = queryManager.getRecords(
                            credentials, PersistencyConstants.META_INFO_TABLE, indexValuesRowKey,
                            null);

                    if (records != null && records.size() > 0) {
                        Record record = records.get(0); // Only one record per sub index is expected..

                        Map<String, String> columns = record.getColumns();

                        List<String> values = new ArrayList<String>();
                        for (String value : columns.keySet()) {
                            values.add(value);
                        }

                        indexValues.put(indexedColumn, values);
                    }

                }
            } catch (StoreException e) {
                throw new IndexingException("Unable to fetch index value information for index "
                                            + indexName + "..", e);
            }

        } catch (ConfigurationException e) {
            throw new IndexingException("Unable to fetch index value information for index "
                                        + indexName + "..", e);
        }

        return indexValues;

    }

    @Override
    public String[] getNextSubIndexValues(String indexName, String subIndex, String subIndexValue,
                                          Map<String, String> credentials)
            throws IndexingException {

        if (!Utils.credentialsValid(credentials)) {
            if (log.isDebugEnabled()) {
                log.debug("Credentials invalid or not yet provided..");
            }
        }

        MetaDataManager metaDataManager = MetaDataManager.getInstance();

        try {
            CassandraIndexConfiguration configuration = (CassandraIndexConfiguration)
                    metaDataManager.getIndexMetaData(credentials, indexName);
            String indexingColumnFamily = configuration.getIndexingColumnFamily();

            QueryManager queryManager = new QueryManager();

            String subIndexValuesRecordKey = PersistencyConstants.INDEX +
                                             PersistencyConstants.INDEX_DELIMITER +
                                             configuration.getIndexName() +
                                             PersistencyConstants.INDEX_DELIMITER +
                                             PersistencyConstants.SUB_INDEX +
                                             PersistencyConstants.INDEX_DELIMITER +
                                             subIndex +
                                             PersistencyConstants.INDEX_DELIMITER +
                                             PersistencyConstants.SUB_INDEX_VALUE +
                                             PersistencyConstants.INDEX_DELIMITER +
                                             subIndexValue;

            try {
                List<Record> records = queryManager.getRecords(
                        credentials, PersistencyConstants.META_INFO_TABLE, subIndexValuesRecordKey,
                        null);

                if (records != null && records.size() > 0) {
                    Record record = records.get(0); // Only one record per sub index is expected..

                    Map<String, String> columns = record.getColumns();

                    List<String> values = new ArrayList<String>();
                    if (columns != null) {
                        for (String value : columns.keySet()) {
                            values.add(value);
                        }
                    }
                    
                    return values.toArray(new String[]{});

                }

            } catch (StoreException e) {
                throw new IndexingException("Unable to fetch index value information for index "
                                            + indexName + "..", e);
            }

        } catch (ConfigurationException e) {
            throw new IndexingException("Unable to fetch index value information for index "
                                        + indexName + "..", e);
        }

        return null;

    }

    /*           Helper methods            */

    public String createRowKey(String[] indexedColumns, Granularity granularity,
                                Map<String, String> columns)
            throws IndexingException {

        StringBuilder buffer = new StringBuilder();

        for (int i = 0; i < indexedColumns.length; i++) {
            String columnName = indexedColumns[i];
            if (columns.containsKey(columnName)) {
                String rowKeyPartValue = columns.get(columnName);

                // handle timestamp case according to granularity
                if (columnName.equals(PersistencyConstants.TIMESTAMP_KEY_NAME)) {
                    try {
                        // we use the time stamp factory to generate the time stamp according to granularity
                        rowKeyPartValue = TimeStampFactory.getFactory().getTimeStamp(
                                columns.get(columnName), granularity);
                    } catch (ParseException e) {
                        throw new IndexingException("Cannot parse time stamp : " +
                                                    columns.get(columnName));
                    }

                }
                buffer.append(rowKeyPartValue);

                // Skip appending row key delimiter for the last row key part
                if ((i + 1) != indexedColumns.length) {
                    buffer.append(PersistencyConstants.INDEX_DELIMITER);
                }


            } else {
                // if there is no column name that corresponds to the row key parts,
                // that means this event should not be inserted, we return null, in that case
                return null;
            }
        }

        buffer.trimToSize();
        return buffer.toString();

    }

    private String[][] getIndexValueArrayOfRecord(Record record,
                                                  IndexConfiguration configuration) {
        String key = record.getKey();

        if (key != null) {
            String[] compositeValues = key.split(PersistencyConstants.INDEX_DELIMITER);

            String[][] indexValues = new String[compositeValues.length][2];

            String[] columns = configuration.getIndexedColumns();

            for (int i = 0; i < compositeValues.length; i++) {
                indexValues[i][0] = columns[i];
                indexValues[i][1] = compositeValues[i];
            }

            return indexValues;

        } else {
            return null;
        }
    }

}

/**
 * Copyright (c) 2009, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.wso2.carbon.bam.analyzer.service;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.wso2.carbon.bam.core.configurations.DataSourceType;
import org.wso2.carbon.bam.core.configurations.IndexConfiguration;
import org.wso2.carbon.bam.core.configurations.TableConfiguration;
import org.wso2.carbon.bam.core.dataobjects.Cursor;
import org.wso2.carbon.bam.core.persistence.IndexManager;
import org.wso2.carbon.bam.core.persistence.MetaDataManager;
import org.wso2.carbon.bam.core.persistence.PersistenceManager;
import org.wso2.carbon.bam.core.persistence.PersistencyConstants;
import org.wso2.carbon.bam.core.persistence.cassandra.CassandraStoreFactory;
import org.wso2.carbon.bam.core.persistence.exceptions.ConfigurationException;
import org.wso2.carbon.bam.core.persistence.exceptions.IndexingException;
import org.wso2.carbon.bam.core.persistence.exceptions.StoreException;
import org.wso2.carbon.context.CarbonContext;
import org.wso2.carbon.core.AbstractAdmin;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

public class IndexMgtService extends AbstractAdmin {

    private static final Log log = LogFactory.getLog(IndexMgtService.class);
    
    public int getTableCount(boolean includeAutoGenerated) throws ConfigurationException{
        
        Map<String, String> credentials = getConnectionParameters();

        MetaDataManager metaDataManager = MetaDataManager.getInstance();
        List<TableConfiguration> tables = metaDataManager.getAllTableMetaData(credentials);
        
        if (tables != null) {

            Iterator<TableConfiguration> iterator = tables.iterator();

            // Remove individual base tables from the result
            while(iterator.hasNext()) {
                TableConfiguration configuration = iterator.next();
                String tableName = configuration.getTableName();
                if (tableName.equals("EVENT") || tableName.equals("META") ||
                    tableName.equals("CORRELATION")) {
                    iterator.remove();
                } else if (!includeAutoGenerated && configuration.getAutoGenerated()) {
                    iterator.remove();
                }
            }

            return tables.size();
        }
        
        return 0;
        
    }
    
    public TableDTO[] getAllTableMetaData(boolean includeAutoGenerated)
            throws ConfigurationException {

        Map<String, String> credentials = getConnectionParameters();

        MetaDataManager metaDataManager = MetaDataManager.getInstance();

        List<TableConfiguration> tables = metaDataManager.getAllTableMetaData(credentials);

        if (tables != null) {

            Iterator<TableConfiguration> iterator = tables.iterator();

            // Remove individual base tables from the result
            while(iterator.hasNext()) {
                TableConfiguration configuration = iterator.next();
                String tableName = configuration.getTableName();
                if (tableName.equals("EVENT") || tableName.equals("META") ||
                    tableName.equals("CORRELATION")) {
                    iterator.remove();
                } else if (!includeAutoGenerated && configuration.getAutoGenerated()) {
                    iterator.remove();
                }
            }
        }

        List<TableDTO> tableDTOs = new ArrayList<TableDTO>();
        for (TableConfiguration table : tables) {
            TableDTO tableDTO = new TableDTO();
            tableDTO.setTableName(table.getTableName());

            if (table.getColumns() != null) {
                tableDTO.setColumns(table.getColumns().toArray(new String[]{}));
            }

            tableDTO.setDataSourceType(table.getDataSourceType().getName());

            tableDTOs.add(tableDTO);
        }

        return tableDTOs.toArray(new TableDTO[]{});

    }

    public TableDTO[] getTableMetaData(int pageNumber, int tablesPerPage,
                                       boolean includeAutoGenerated)
            throws ConfigurationException {

        Map<String, String> credentials = getConnectionParameters();

        MetaDataManager metaDataManager = MetaDataManager.getInstance();

        List<TableConfiguration> tables = metaDataManager.getAllTableMetaData(credentials);
        Iterator<TableConfiguration> iterator = tables.iterator();

        // Remove individual base tables from the result
        while(iterator.hasNext()) {
            TableConfiguration configuration = iterator.next();
            String tableName = configuration.getTableName();
            if (tableName.equals("EVENT") || tableName.equals("META") ||
                tableName.equals("CORRELATION")) {
                iterator.remove();
            } else if (!includeAutoGenerated && configuration.getAutoGenerated()) {
                iterator.remove();
            }
        }
        
        List<TableConfiguration> pageOfTables = new ArrayList<TableConfiguration>();
        if (tables != null) {

            if (tables.size() >= (tablesPerPage * pageNumber + tablesPerPage)) {
                // In a middle page
                for (int i = 0; i < tablesPerPage; i++) {
                    pageOfTables.add(tables.get(tablesPerPage * pageNumber + i));
                }
            } else if (tables.size() <= (tablesPerPage * pageNumber)) { 
            // Tables have been deleted while paged access is happening.
            // Show the last page of existing tables.
                int size = tables.size();

                int resultCount = (size < tablesPerPage ? size : tablesPerPage);

                for (int i = 1; i < resultCount; i++) {
                    pageOfTables.add(tables.get(size - i));
                }
            } else {
                // In the last page
                for (int i = tablesPerPage * pageNumber ; i < tables.size() ; i++) {
                    pageOfTables.add(tables.get(i));
                }
            }
        }
        
        List<TableDTO> tableDTOs = new ArrayList<TableDTO>();
        for (TableConfiguration table : pageOfTables) {
            TableDTO tableDTO = new TableDTO();
            tableDTO.setTableName(table.getTableName());

            if (table.getColumns() != null) {
                tableDTO.setColumns(table.getColumns().toArray(new String[]{}));
            }

            tableDTO.setDataSourceType(table.getDataSourceType().getName());

            tableDTOs.add(tableDTO);
        }

        return tableDTOs.toArray(new TableDTO[]{});

    }
    
    public TableDTO getSingleTableMetaData(String tableName) throws ConfigurationException {

        int tenantId = CarbonContext.getCurrentContext().getTenantId();

        getConnectionParameters(); // Call this to initialize meta data store

        MetaDataManager metaDataManager = MetaDataManager.getInstance();

        TableConfiguration configuration = metaDataManager.getTableMetaData(tenantId, tableName);
        
        TableDTO tableDTO = new TableDTO();
        tableDTO.setTableName(configuration.getTableName());
        
        if (configuration.getColumns() != null) {
            tableDTO.setColumns(configuration.getColumns().toArray(new String[]{}));
        }

        tableDTO.setDataSourceType(configuration.getDataSourceType().getName());

        return tableDTO;
        
    }
    
    public void createTable(TableDTO table) throws ConfigurationException, StoreException {

        Map<String, String> credentials = getConnectionParameters();
        
        List<String> tableColumns = new ArrayList<String>();

        if (table.getColumns() != null) {
            for (String tableColumn : tableColumns) {
                tableColumns.add(tableColumn);
            }
        }

        MetaDataManager metaDataManager = MetaDataManager.getInstance();
        TableConfiguration tableConfiguration = metaDataManager.createTableMetaData(
                table.getTableName(), tableColumns,
                DataSourceType.valueOf(table.getDataSourceType()), false);
        PersistenceManager persistenceManager = new PersistenceManager();
        persistenceManager.createTable(credentials, tableConfiguration);
        
    }
    
    public void deleteTable(String tableName) throws ConfigurationException, StoreException {

        Map<String, String> credentials = getConnectionParameters();

        PersistenceManager persistenceManager = new PersistenceManager();
        persistenceManager.deleteTable(credentials, tableName);

    }

    public CursorDTO[] getAllCursors() throws ConfigurationException {

        Map<String, String> credentials = getConnectionParameters();

        MetaDataManager metaDataManager = MetaDataManager.getInstance();

        List<Cursor> cursors = metaDataManager.getAllCursorMetaData(credentials);

        List<CursorDTO> cursorDTOs = new ArrayList<CursorDTO>();
        for (Cursor cursor : cursors) {
            CursorDTO cursorDTO = new CursorDTO();
            cursorDTO.setCursorName(cursor.getCursorName());
            cursorDTO.setResumePoint(cursor.getResumePoint());

            cursorDTOs.add(cursorDTO);
        }

        return cursorDTOs.toArray(new CursorDTO[]{});

    }

    public void createIndex(IndexDTO index) throws ConfigurationException, IndexingException {

        DataSourceType dataSourceType = DataSourceType.valueOf(index.getDataSourceType());

        MetaDataManager metaDataManager = MetaDataManager.getInstance();
        
        Map<String, String> configurations = new HashMap<String, String>();
        configurations.put(PersistencyConstants.CRON, index.getCron());
        configurations.put(PersistencyConstants.GRANULARITY, index.getGranularity());

        IndexConfiguration configuration = metaDataManager.createIndexMetaData(
                index.getIndexName(), index.getIndexedTable(), index.getIndexedColumns(),
                dataSourceType, configurations);

        Map<String, String> credentials = getConnectionParameters();

        IndexManager indexManager = IndexManager.getInstance();
        indexManager.createIndex(configuration, credentials);

    }
    
    public void editIndex(IndexDTO index) throws ConfigurationException, IndexingException {

        DataSourceType dataSourceType = DataSourceType.valueOf(index.getDataSourceType());

        MetaDataManager metaDataManager = MetaDataManager.getInstance();

        Map<String, String> configurations = new HashMap<String, String>();
        configurations.put(PersistencyConstants.CRON, index.getCron());

        IndexConfiguration configuration = metaDataManager.createIndexMetaData(
                index.getIndexName(), index.getIndexedTable(), index.getIndexedColumns(),
                dataSourceType, configurations);

        Map<String, String> credentials = getConnectionParameters();

        IndexManager indexManager = IndexManager.getInstance();
        indexManager.editIndex(configuration, credentials);

    }
    
    public void deleteIndex(String indexName) throws ConfigurationException, IndexingException {

        Map<String, String> credentials = getConnectionParameters();

        IndexManager indexManager = IndexManager.getInstance();
        indexManager.deleteIndex(indexName, credentials);

    }
    
    public int getIndexCount() throws ConfigurationException {

        Map<String, String> credentials = getConnectionParameters();

        MetaDataManager metaDataManager = MetaDataManager.getInstance();
        List<IndexConfiguration> indexes = metaDataManager.getAllIndexMetaData(credentials);

        if (indexes != null) {
            return indexes.size();
        }

        return 0;

    }

    public IndexDTO[] getIndexMetaData(int pageNumber, int indexesPerPage)
    throws ConfigurationException {

        Map<String, String> credentials = getConnectionParameters();

        MetaDataManager metaDataManager = MetaDataManager.getInstance();
        List<IndexConfiguration> indexes = metaDataManager.getAllIndexMetaData(credentials);

        List<IndexConfiguration> pageOfIndexes = new ArrayList<IndexConfiguration>();
        if (indexes != null) {
            if (indexes.size() >= (indexesPerPage * pageNumber + indexesPerPage)) {
                // In a middle page
                for (int i = 0; i < indexesPerPage; i++) {
                    pageOfIndexes.add(indexes.get(indexesPerPage * pageNumber + i));
                }
            } else if (indexes.size() <= (indexesPerPage * pageNumber)) {
                // Indexes have been deleted while paged access is happening.
                // Show the last page of existing indexes.
                int size = indexes.size();

                int resultCount = (size < indexesPerPage ? size : indexesPerPage);

                for (int i = 1; i < resultCount; i++) {
                    pageOfIndexes.add(indexes.get(size - resultCount));
                }
            } else {
                // In the last page
                for (int i = indexesPerPage * pageNumber ; i < indexes.size() ; i++) {
                    pageOfIndexes.add(indexes.get(i));
                }
            }
        }

        List<IndexDTO> indexDTOs = new ArrayList<IndexDTO>();
        for (IndexConfiguration configuration : pageOfIndexes) {
            IndexDTO indexDTO = new IndexDTO();
            indexDTO.setIndexName(configuration.getIndexName());
            indexDTO.setIndexedTable(configuration.getIndexedTable());
            indexDTO.setIndexedColumns(configuration.getIndexedColumns());
            indexDTO.setDataSourceType(configuration.getDataSourceType().name());
            indexDTO.setAutoGenerated(configuration.isAutoGenerated());
            indexDTO.setManuallyIndexed(configuration.isManuallyIndexed());
            indexDTOs.add(indexDTO);
        }

        return indexDTOs.toArray(new IndexDTO[]{});

    }

    public IndexDTO getIndex(String indexName) throws ConfigurationException {

        Map<String, String> credentials = getConnectionParameters();

        MetaDataManager metaDataManager = MetaDataManager.getInstance();
        IndexConfiguration configuration = metaDataManager.getIndexMetaData(credentials, indexName);

        if (configuration == null) {
            String msg = "Check whether You have created and index with name: " + indexName + " Or you have provided valid credentials";
            log.error(msg);
            throw new ConfigurationException(msg);
        }

        DataSourceType type = configuration.getDataSourceType();

        IndexDTO index = new IndexDTO();
        index.setIndexName(configuration.getIndexName());
        index.setIndexedTable(configuration.getIndexedTable());
        index.setDataSourceType(type.getName() + ":" + type.isManuallyIndexed());
        index.setAutoGenerated(configuration.isAutoGenerated());
        index.setManuallyIndexed(configuration.isManuallyIndexed());
        index.setIndexedColumns(configuration.getIndexedColumns());

        return index;

    }
    
    public String[] getIndexValues(String indexName, String indexedColumn)
            throws ConfigurationException, IndexingException {

        Map<String, String> credentials = getConnectionParameters();

        IndexManager indexManager = IndexManager.getInstance();
        List<String> indexValues = indexManager.
                getIndexValues(indexName, indexedColumn, credentials);
        
        if (indexValues != null) {
            return indexValues.toArray(new String[]{});
        }

        return null;

    }
    
    public String[] getSubIndexValues(String indexName, String subIndex, String subIndexValue)
            throws ConfigurationException, IndexingException {

        Map<String, String> credentials = getConnectionParameters();

        IndexManager indexManager = IndexManager.getInstance();
        String[] indexValues = indexManager.getSubIndexValues(indexName, subIndex,
                                                                  subIndexValue, credentials);

        if (indexValues != null) {
            return indexValues;
        }

        return null;    
    }
    
    public String getDataSourceTypeOfTable(String tableName) throws ConfigurationException {
        int tenantId = CarbonContext.getCurrentContext().getTenantId();

        MetaDataManager metaDataManager = MetaDataManager.getInstance();
        TableConfiguration configuration = metaDataManager.getTableMetaData(tenantId, tableName);

        DataSourceType type = configuration.getDataSourceType();

        return type.getName() + ":" + type.isManuallyIndexed();

    }

    public String[] getDataSourceTypes() {

        PersistenceManager persistenceManager = new PersistenceManager();
        DataSourceType[] dataSourceTypes = persistenceManager.getDataSourceTypes();

        List<String> dataSourceInfo = new ArrayList<String>();
        for (DataSourceType dataSourceType : dataSourceTypes) {
            dataSourceInfo.add(dataSourceType.getName() + ":" + dataSourceType.isManuallyIndexed());
        }

        // CASSANDRA will be the default choice currently due to this re-ordering.
        String[] dataSourceTypeArray = dataSourceInfo.toArray(new String[]{});
        Arrays.sort(dataSourceTypeArray);
        return dataSourceTypeArray;

    }

    private Map<String, String> getConnectionParameters() throws ConfigurationException {

        int tenantId = CarbonContext.getCurrentContext().getTenantId();
        Map<String, String> credentials = org.wso2.carbon.bam.core.utils.Utils.
                getConnectionParameters(tenantId);

        if (!credentialsValid(credentials)) {
            throw new ConfigurationException("Credentials invalid or not supplied yet..");
        }

        // Initialize meta data related tables before doing meta data operations
        try {
            CassandraStoreFactory.getInstance().getDataStore(credentials);
        } catch (StoreException e) {
            throw new ConfigurationException("Unable to initialize meta data store..");
        }

        return credentials;

    }

    private boolean credentialsValid(Map<String, String> credentials) {
        if (credentials == null) {
            return false;
        }

        if (credentials.size() < 2) {
            return false;
        }

        for (Map.Entry<String, String> entry : credentials.entrySet()) {

            String key = entry.getKey();
            String value = entry.getValue();

            if (key == null || value == null) {
                return false;
            }

            if (!key.equals(PersistencyConstants.USER_NAME) &&
                !key.equals(PersistencyConstants.PASSWORD)) {
                return false;
            }
        }

        return true;

    }

}

<%

var gregUrl = "https://localhost:9443/";


function loginFunc(username, password, remoteAddress) {
    var url = gregUrl + "services/AuthenticationAdmin";
    var payload =
        <aut:login xmlns:aut="http://authentication.services.core.carbon.wso2.org">
            <aut:username>{username}</aut:username>
            <aut:password>{password}</aut:password>
            <aut:remoteAddress>{remoteAddress}</aut:remoteAddress>
        </aut:login>;
    var result = invokeService(url, payload, "urn:login");
    if (result.error) {
        log("Error while authenticating user : " + username + " at " + remoteAddress, "error");
        return {
            error:result.error,
            cookie:null
        };
    }
    var xml = result.client.responseE4X;
    var ns = "http://authentication.services.core.carbon.wso2.org";
    var status = xml.ns::["return"].text().toString();
    if(status == "false") {
        log("Error verifying credentials for user : " + username + " at " + remoteAddress, "error");
        return {
            error:true,
            cookie:null
        };
    }
    var subscriber = apiStore.getSubscriber(username);
    if(!subscriber) {
        apiStore.addSubscriber(username);
        subscriber = apiStore.getSubscriber(username);
    }
    log(username);
    log(xml);
    var cookie = result.client.getResponseHeader("Set-Cookie");
    log(cookie);
    cookie = cookie.split(';')[0];
    session.put("username", username);
    session.put("userId", subscriber.id);
    session.put("cookie", cookie);
    return {
        error:false,
        cookie:cookie
    };
}

function logoutFunc() {
    session.put("username", null);
    session.put("cookie", null);

    return {
        error:false
    };
}

function getUserFunc() {
    return {
        username:session.get("username"),
        cookie:session.get("cookie"),
        id : session.get("userId")
    };
}


function getServicesFunc() {
    var url = gregUrl + "services/ListMetadataService.ListMetadataServiceHttpsSoap11Endpoint/";
    var payload = <ser:listservices xmlns:ser="http://services.list.governance.carbon.wso2.org"></ser:listservices>;
    var result = invokeService(url, payload, "urn:listservices", null);
    if (result.error) {
        log("Error getting services", "error");
        return {
            error:result.error,
            services:null
        };
    }

    var getPath = function (pathString) {
        var fullPath = "/";
        var pathA = pathString.split('/');


        if(pathA[3]=="branches" || pathA[1]=="branches"){
        	 return pathString;
        }else{

        for (var i = 1; i < pathA.length - 2; i++) {

            fullPath += pathString.split('/')[i] + '/';
        }
        return fullPath;
        }
    };

    var xml = result.client.responseE4X;
    var ns = "http://services.list.governance.carbon.wso2.org";
    var ax2211 = "http://beans.list.governance.carbon.wso2.org/xsd";
    var services = [];
    var names = xml.ns::["return"].ax2211::names;
    var canDeletes = xml.ns::["return"].ax2211::canDelete;
    var paths = xml.ns::["return"].ax2211::path;
    var namespaces = xml.ns::["return"].ax2211::namespace;
    for (var i = 0; i < names.length(); i++) {

    	   var path = getPath(paths[i].text().toString());
    	        var dr = getDescriptionFunc(path, "all");
    	        if (dr.error) {
    	            continue;
    	        } else {
    	            var descriptionStr = dr.description.description;
    	           // log("description :: "+descriptionStr);
    	           // addedTime.push(description.createdTime);
    	          // servicesObj[description.createdTime] = service;
    	        }

     var newone =true;
        log("Path :: "+path);
        var ars = getAverageRatingFunc(path);
        var avgRating;
        if (ars.error) {
        	avgRating = 0;
        }
        else {
        	avgRating = ars.rating;
            var content = getResourceContentFunc('/_system/governance' + getPath(paths[i].text().toString()));

            for(var k = 0; k < services.length; k++)
            {

              if(services[k].name == names[i].text().toString())
              {
            	  newone=false;
            	  if(services[k].version < content.version)
                  {
            		  services.splice(k,1);
            		  newone=true;
                  }
              }else{
            	  newone=true;
            	  }
            }
                if(newone){
            var elem = {
                name:names[i].text().toString(),
                canDelete:canDeletes[i].text().toString(),
                namespace:namespaces[i].text().toString(),
                path:getPath(paths[i].text().toString()),
                rating:avgRating,
                description:descriptionStr,
                purchased:isPurchased(names[i].text().toString()),
                thumbURL:content.ThumbURL,
                version:content.version,
                author:content.author,
                supportForumURL:content.supportForumURL
            };
            services.push(elem);
            }

        }
    }
    return {
        error:false,
        services:services
    };
}

function getTopRatedServicesFunc() {
    var result = getServicesFunc();
    if (result.error) {
        return {
            error:result.error,
            topRated:null
        };
    }
    var topRated = [];
    var services = result.services;
    for (var i = 0; i < services.length; i++) {
        var service = services[i];
        if (service.rating > 4) {
            topRated.push(service);
        }
    }
    return {
        error:false,
        topRated:topRated
    };
}

function getRecentlyAddedServicesFunc() {
    var result = getServicesFunc();
    if (result.error) {
        return {
            error:result.error,
            recentlyAdded:null
        };
    }
    var recentlyAdded = [];
    var addedTime = [];
    var servicesObj = {};
    var services = result.services;
    for (var i = 0; i < services.length; i++) {
        var service = services[i];
        var dr = getDescriptionFunc(service.path, "all");
        if (dr.error) {
            continue;
        } else {
            var description = dr.description;
            addedTime.push(description.createdTime);
            servicesObj[description.createdTime] = service;
        }
    }
    addedTime = addedTime.sort(function (a, b) {
        return b - a;
    });
    for (i = 0; i < addedTime.length; i++) {
        recentlyAdded.push(servicesObj[addedTime[i]]);
    }
    return {
        error:false,
        recentlyAdded:recentlyAdded
    };
}

function getRatingFunc(path) {
    var url = gregUrl + "services/WSRegistryService.WSRegistryServiceHttpsSoap11Endpoint/";
    var payload =
        <api:getRating xmlns:api="http://api.ws.registry.carbon.wso2.org">
            <api:path>/_system/governance{path}</api:path>
            <api:userName>{getUserFunc().username}</api:userName>
        </api:getRating>;
    var result = invokeService(url, payload, "urn:getRating", null);
    if (result.error) {
        log("Error getting rating for the resource at " + path, "error");
        return {
            error:result.error,
            rating:null
        };
    }
    var xml = result.client.responseE4X;
    var ns = "http://api.ws.registry.carbon.wso2.org";
    return {
        error:false,
        rating:xml.ns::["return"].text().toString()
    };
}

function getAverageRatingFunc(path) {
    var url = gregUrl + "services/WSRegistryService.WSRegistryServiceHttpsSoap11Endpoint/";
    var payload =
        <api:getAverageRating xmlns:api="http://api.ws.registry.carbon.wso2.org">
            <api:resourcePath>/_system/governance{path}</api:resourcePath>
        </api:getAverageRating>;
    var result = invokeService(url, payload, "urn:getAverageRating", null);
    if (result.error) {
        log("Error getting average rating for the resource at " + path, "error");
        return {
            error:result.error,
            rating:null
        };
    }
    // log("path :: "+path);
    var xml = result.client.responseE4X;
    var ns = "http://api.ws.registry.carbon.wso2.org";
    return {
        error:false,
        rating:xml.ns::["return"].text().toString()
    };
}

function getDescriptionFunc1(path, type) {
    var url = gregUrl + "services/WSRegistryService.WSRegistryServiceHttpsSoap11Endpoint/";
    var payload =
        <api:WSgetMetaData xmlns:api="http://api.ws.registry.carbon.wso2.org">
            <api:path>/_system/governance{path}</api:path>
        </api:WSgetMetaData>;
    var result = invokeService(url, payload, "urn:WSgetMetaData", null);
    if (result.error) {
        log("Error getting description for resource at " + path, "error");
        return {
            error:result.error,
            description:null
        };
    }
    var content = getResourceContentFunc('/_system/governance' +path );

    var rs = getRatingFunc(path);
    var ars = getAverageRatingFunc(path);
    var rating;
    var avgRating;
    if (rs.error) {
        rating = 0;
    }
    if (rs.error) {
    	avgRating = 0;
    }
    rating = rs.rating;
    avgRating = ars.rating;
    var xml = result.client.responseE4X;
    var ns = "http://api.ws.registry.carbon.wso2.org";
    var ax2430 = "http://api.ws.registry.carbon.wso2.org/xsd";
    if (type == "all") {
        var description = {
            versionNumber:xml.ns::["return"].ax2430::versionNumber.text().toString(),
            description:xml.ns::["return"].ax2430::description.text().toString(),
            parentPath:xml.ns::["return"].ax2430::parentPath.text().toString(),
            createdTime:xml.ns::["return"].ax2430::createdTime.text().toString(),
            authorUserName:xml.ns::["return"].ax2430::authorUserName.text().toString(),
            lastModified:xml.ns::["return"].ax2430::lastModified.text().toString(),
            lastUpdaterUserName:xml.ns::["return"].ax2430::lastUpdaterUserName.text().toString(),
            path:path,
            purchased:isPurchased(content.name),
            rating:rating,
            averageRating:avgRating,
            thumbURL:content.ThumbURL,
            author:content.author,
            description:content.description,
            name:content.name,
            version:content.version,
            namespace:content.namespace,
            supportForumURL:content.supportForumURL,
            wsdlURL:content.wsdlURL,
            mediaType:xml.ns::["return"].ax2430::mediaType.text().toString()
        };
        return {
            error:false,
            description:description
        };
    } else if (type == "author") {
        var author =
            xml.ns::["return"].ax2430::authorUserName.text().toString();
        return {
            error:false,
            author:author
        };
    }else if (type == "describition") {

        	  var description ={
        			  description:xml.ns::["return"].ax2430::description.text().toString()
        	  }
        // log("ax2430::description"+description.length);
              return {
                  error:false,
                  description:description
              };
    }

}

function getTagsFunc(path) {
    var url = gregUrl + "services/WSRegistryService.WSRegistryServiceHttpsSoap11Endpoint/";
    var payload =
        <api:WSgetTags xmlns:api="http://api.ws.registry.carbon.wso2.org">
            <api:resourcePath>/_system/governance{path}</api:resourcePath>
        </api:WSgetTags>;
    var result = invokeService(url, payload, "urn:WSgetTags", null);
    if (result.error) {
        log("Error getting tags for the resource at " + path, "error");
        return {
            error:result.error,
            tags:null
        };
    }

    var xml = result.client.responseE4X;
    var ns = "http://api.ws.registry.carbon.wso2.org";
    var ax2430 = "http://api.ws.registry.carbon.wso2.org/xsd";
    var tagEl = xml.ns::["return"].ax2430::tagName;
    var tags = [];
    for (var i = 0; i < tagEl.length(); i++) {
        tags[i] = tagEl[i].text().toString();
    }
    return {
        error:false,
        tags:tags
    };
}

function getTagCloudFunc() {
    var result = getServicesFunc();
    if (result.error) {
        return {
            error:result.error,
            topCloud:null
        };
    }
    var tagCloud = [];
    var tagCount = {};
    var services = result.services;
    for (var i = 0; i < services.length; i++) {
        var service = services[i];
        var tr = getTagsFunc(service.path);
        if (tr.error) {
            continue;
        } else {
            var tags = tr.tags;
            for (var j = 0; j < tags.length; j++) {
                var tag = tags[j];
                if (tagCount[tag]) tagCount[tag] = tagCount[tag] + 1;
                else tagCount[tag] = 1;
            }
        }
    }
    for (var tag in tagCount) {
        tagCloud.push({
            name:tag,
            count:tagCount[tag]
        });
    }
    return {
        error:false,
        tagCloud:tagCloud
    };
}

function purchaseServiceFunc(serviceName, servicePath, username) {
    var assocPath = '/application/service_store/consumer/' + username + '/purchase/' + serviceName;
    var msg = "Error purchasing service " + serviceName + " at " + servicePath + " for user : " + username;
    var result = createResourceFunc(assocPath);
    if (result.error) {
     // log(msg, "error");
        return {
            error:result.error,
            purchased:false
        };
    }
    result = createAssociationFunc(assocPath, servicePath);
    if (result.error) {
        log(msg, "error");
        return {
            error:result.error,
            purchased:false
        };
    }
    return {
        error:false,
        purchased:true
    };
}

function uninstallServiceFunc(serviceName, servicePath, username) {
    var assocPath = '/application/service_store/consumer/' + username + '/purchase/' + serviceName;
    var msg = "Error purchasing service " + serviceName + " at " + servicePath + " for user : " + username;
    var result = deleteResourceFunc(assocPath);
    if (result.error) {
        log(msg, "error");
        return {
            error:result.error,
            purchased:false
        };
    }
    return {
        error:false,
        purchased:result.deleted
    };
}

function createResourceFunc(path) {

    var url = gregUrl + "services/ResourceAdminService.ResourceAdminServiceHttpsSoap11Endpoint/";
    var payload =
        <ser:addResource xmlns:ser="http://services.resource.registry.carbon.wso2.org">
            <ser:path>{path}</ser:path>
        </ser:addResource>;
    var result = invokeService(url, payload, "urn:addResource", null);
    if (result.error) {
        log("Error while creating resource at " + path, "error");
        return {
            error:true
        };
    }
    var xml = result.client.responseE4X;
    var services = new Array();
    var ns = "http://services.resource.registry.carbon.wso2.org";
    var created = xml.ns::["return"][0].text().toString();
    created = created == "true";
    return {
        error:false,
        created:created
    };
}

function deleteResourceFunc(path) {

    var url = gregUrl + "services/ResourceAdminService.ResourceAdminServiceHttpsSoap11Endpoint/";
    var payload =
        <ser:delete xmlns:ser="http://services.resource.registry.carbon.wso2.org">
            <ser:pathToDelete>{path}</ser:pathToDelete>
        </ser:delete>;
    var result = invokeService(url, payload, "urn:delete", null);
    if (result.error) {
        log("Error while deleting resource at " + path, "error");
        return {
            error:true,
            deleted:false
        };
    }
    var xml = result.client.responseE4X;
    var services = new Array();
    var ns = "http://services.resource.registry.carbon.wso2.org";
    var deleted = xml.ns::["return"][0].text().toString();
    deleted = deleted == "true";
    return {
        error:false,
        deleted: deleted
    };
}

function createAssociationFunc(source, target) {
    var url = gregUrl + "services/WSRegistryService.WSRegistryServiceHttpsSoap11Endpoint/";
    var payload =
        <api:addAssociation  xmlns:api="http://api.ws.registry.carbon.wso2.org">
            <api:sourcePath>{source}</api:sourcePath>
            <api:targetPath>/_system/governance{target}</api:targetPath>
            <api:associationType>purch</api:associationType>
        </api:addAssociation>;

    var options = {
        mep:'in-only'
    };
    invokeService(url, payload, "urn:addAssociation", options);
    return {
        error:false,
        associated:true
    };
}

function getPurchasesFunc(username) {
    var url = gregUrl + "services/WSRegistryService.WSRegistryServiceHttpsSoap11Endpoint/";
    var payload =
        <api:getCollectionContent xmlns:api="http://api.ws.registry.carbon.wso2.org">
            <api:path>/application/service_store/consumer/{username}/purchase</api:path>
        </api:getCollectionContent>;
    var result = invokeService(url, payload, "urn:getCollectionContent", null);
    if (result.error) {
        log("Error getting purchases for user : " + username, "error");
        return {
            error:result.error,
            purchases:null
        };
    }
    var purchases = [];
    var xml = result.client.responseE4X;
    var ns = "http://api.ws.registry.carbon.wso2.org";
    var names = xml.ns::["return"];
    for (var i = 0; i < names.length(); i++) {
        purchases.push(names[i].text().toString().split('purchase/')[1]);
    }
    return {
        error:false,
        purchases:purchases
    };
}


function getServicesForApplicationFunc(applicationname) {
    var url = gregUrl + "services/WSRegistryService.WSRegistryServiceHttpsSoap11Endpoint/";
    var payload =
        <api:getCollectionContent xmlns:api="http://api.ws.registry.carbon.wso2.org">
            <api:path>/application/service_store/applications/{applicationname}</api:path>
        </api:getCollectionContent>;
    var result = invokeService(url, payload, "urn:getCollectionContent", null);
    if (result.error) {
        log("Error getting services from Application  " + applicationname, "error");
        return {
            error:result.error,
            purchases:null
        };
    }
    var services = [];
    var xml = result.client.responseE4X;
    var ns = "http://api.ws.registry.carbon.wso2.org";
    var names = xml.ns::["return"];
    for (var i = 0; i < names.length(); i++) {
    	services.push(names[i].text().toString().split(''+applicationname+'/')[1]);
    }
    return {
        error:false,
        services:services
    };
}

function getApplicationPropertyFunc(applicationname,property) {
    var url = gregUrl + "services/ResourceAdminService.ResourceAdminServiceHttpsSoap11Endpoint/";
    var payload =
    	 <ser:getProperty xmlns:ser="http://services.resource.registry.carbon.wso2.org">
    <ser:resourcePath>/application/service_store/applications/{applicationname}</ser:resourcePath>
    <ser:key>{property}</ser:key>
 </ser:getProperty>;
    var result = invokeService(url, payload, "urn:getProperty", null);
    if (result.error) {
        log("Error getting property "+property+" from Application  " + applicationname, "error");
        return {
            error:result.error,
            purchases:null
        };
    }
    var proptyValueout = "";
    var xml = result.client.responseE4X;
    var ns = "http://services.resource.registry.carbon.wso2.org";
    var proptyValue = xml.ns::["return"];
  // log("proptyValue"+proptyValue);
    	proptyValueout = proptyValue.text().toString();

    return {
        error:false,
        proptyValue:proptyValueout
    };
}

function getApplicationsFunc(username) {
    var applications = apiStore.getApplications(username);
    return {
        error : false,
        applications : applications
    };
}

function addApplicationFunc(name, username) {
    var added = apiStore.addApplication(name, username);
    return {
        error : false,
        added : added
    };
}


function searchServiceFunc(key, name) {
    var url = gregUrl + "services/SearchAdminService.SearchAdminServiceHttpsSoap11Endpoint/";
    var payload =
        <ser:getAdvancedSearchResults
        xmlns:ser="http://services.search.registry.carbon.wso2.org"
        xmlns:xsd="http://beans.search.registry.carbon.wso2.org/xsd">
            <ser:parameters>
                <xsd:parameterValues>
                    <xsd:array>{key}</xsd:array>
                    <xsd:array>{name}</xsd:array>
                </xsd:parameterValues>
                <xsd:parameterValues>
                    <xsd:array>mediaType</xsd:array>
                    <xsd:array>application/vnd.wso2-service+xml</xsd:array>
                </xsd:parameterValues>
            </ser:parameters>
        </ser:getAdvancedSearchResults>;

    var result = invokeService(url, payload, "urn:getAdvancedSearchResults", null);
    if (result.error) {
        log("Error searching services key : " + key + ", name : " + name, "error");
        return {
            error:result.error,
            services:null
        }
    }
    var services = [];
    var xml = result.client.responseE4X;
    var ns = "http://services.search.registry.carbon.wso2.org";
    var ax2427 = "http://common.registry.carbon.wso2.org/xsd";
    var ax2425 = "http://beans.search.registry.carbon.wso2.org/xsd";
    var rdl = xml.ns::["return"].ax2425::["resourceDataList"];
    for (var i = 0; i < rdl.length(); i++) {
        var content = getResourceContentFunc(rdl[i].ax2427::['resourcePath'].text().toString());
        var path = rdl[i].ax2427::['resourcePath'].text().toString();
        path = path.substring(path.indexOf("/_system/governance") + 19);
        services.push({
            name:rdl[i].ax2427::['name'].text().toString(),
            canDelete:rdl[i].ax2427::['deleteAllowed'].text().toString(),
            namespace:null,
            path:path,
            rating:rdl[i].ax2427::['averageRating'].text().toString(),
            purchased:isPurchased(rdl[i].ax2427::['name'].text().toString()),
            thumbURL:content.ThumbURL,
            supportForumURL:content.supportForumURL
        });
    }

    if (key == "resourcePath" && services.length != 0) {
        saveSearchTerm(name);
    }

    return {
        error:false,
        services:services
    }
}

function saveSearchTerm(name) {
    var path = '/application/service_store/metadata/search_terms/' + name;
    createResourceFunc(path);
}

function getSearchKeysFunc() {
    var result = getResourceNamesInCollectionFunc("/application/service_store/metadata/search_terms/");
    if(result.error == "true"){
        return result;
    }
    return {
        error:false,
        resourceNames:result.resourceNames
    }
}

function getResourceNamesInCollectionFunc(path) {
    var url = gregUrl + "services/ResourceAdminService.ResourceAdminServiceHttpsSoap11Endpoint/";
    // log(path);

    if (path.charAt(path.length - 1) == "/") {
        path = path.substring(0, path.length - 1);
    }

    var payload =
        <ser:getCollectionContent xmlns:ser="http://services.resource.registry.carbon.wso2.org">
            <ser:path>{path}</ser:path>
        </ser:getCollectionContent>

    var result = invokeService(url, payload, "urn:getCollectionContent", null);
    if (result.error) {
        log("Error while getting resources at " + path, "error");
        return {
            error:true
        };
    }
    var xml = result.client.responseE4X;
    var services = new Array();
    var ns = "http://services.resource.registry.carbon.wso2.org";
    var ax2414 = "http://beans.resource.registry.carbon.wso2.org/xsd";
    var paths = xml.ns::["return"].ax2414::["childPaths"];

    var resNames = [];

    for (var id in paths) {
        resNames.push(paths[id].split("/application/service_store/metadata/search_terms/")[1]);
    }

    return {
        error:false,
        resourceNames:resNames
    };
}


function invokeService(url, payload, action, opts) {
	var ws = require('ws');
    var client = new ws.WSRequest();
    var options = [];
    options.useSOAP = 1.2;
    options.userWSA = 1.0;
    options.action = action;
    var user = getUserFunc();
    if (user.cookie) {
        options.HTTPHeaders = [
            { name:"Cookie", value:user.cookie }
        ];
    }
    if (opts) {
        for (var key in opts) {
            options[key] = opts[key];
        }
    }
    try {
        client.open(options, url, false);
        client.send(payload);
        return {
            client:client,
            error:false
        };
    } catch (e) {
        log("Error invoking service " + url + ", action : " + options.action + ", " + e.toString());
        return {
            client:client,
            error:e
        };
    }
}

function isPurchased(servicen) {
    var allservices = getPurchases(getUserFunc().username);
    if (!allservices.error) {
        for (var s in allservices.data.purchases) {
            if (allservices.data.purchases[s].search(servicen) > -1) {
                return true;
            }
        }
    }
    return false;
}

function rateResourceFunc(path, rating) {
    var url = gregUrl + "services/WSRegistryService";
    var payload =
            <api:rateResource xmlns:api="http://api.ws.registry.carbon.wso2.org">
                <api:resourcePath>/_system/governance{path}</api:resourcePath>
                <api:rating>{rating}</api:rating>
            </api:rateResource>;
    var options = {
        mep:'in-only'
    };
    var result = invokeService(url, payload, "urn:rateResource", options);
    if (result.error) {
        log("Error rating the resource " + path, "error");
        return {
            error:result.error
        };
    }

    var averageRateResults = getAverageRatingFunc(path);
    var rateResults = getRatingFunc(path);
    if (averageRateResults.error) {
        avgRating = 0;
    }
    else {
        avgRating = averageRateResults.rating;
    }
    if (rateResults.error) {
        userRating = 0;
    } else {
        userRating = rateResults.rating;
    }

    return {
        error:false,
        rating:userRating,
        averageRating:avgRating
    };
}

function addCommentFunc(path, comment) {
    var url = gregUrl + "services/WSRegistryService";
    var username = getUserFunc().username;
    if (username) {
        var payload =
            <api:WSaddComment xmlns:api="http://api.ws.registry.carbon.wso2.org" xmlns:xsd="http://api.ws.registry.carbon.wso2.org/xsd">
                <api:resourcePath>/_system/governance{path}</api:resourcePath>
                <api:comment>
                    <xsd:text>{comment}</xsd:text>
                    <xsd:user>{username}</xsd:user>
                </api:comment>
            </api:WSaddComment>;
        var result = invokeService(url, payload, "urn:WSaddComment", null);
        if (result.error) {
            log("Error adding the comment for resource " + path, "error");
            return {
                error:result.error,
                comment:null
            };
        }
        var xml = result.client.responseE4X;
        var ns = "http://api.ws.registry.carbon.wso2.org";
        return {
            error:false,
            comment:xml.ns::["return"].text().toString()
        };
    } else {
        log("Logged in user cannot be found");
        return {
            error:true,
            comment:null
        };
    }
}

function getCommentsFunc(path) {
    var url = gregUrl + "services/WSRegistryService";
    var payload =
        <api:WSgetComments xmlns:api="http://api.ws.registry.carbon.wso2.org">
            <api:resourcePath>/_system/governance{path}</api:resourcePath>
        </api:WSgetComments>;
    var result = invokeService(url, payload, "urn:WSgetComments", null);
    if (result.error) {
        log("Error getting the comments for resource " + path, "error");
        return {
            error:result.error,
            comments:null
        };
    }
    var xml = result.client.responseE4X;
    var ns = "http://api.ws.registry.carbon.wso2.org";
    var ax2427 = "http://api.ws.registry.carbon.wso2.org/xsd";
    var comments = [];
    var paths = xml.ns::["return"].ax2427::path;
    var times = xml.ns::["return"].ax2427::time;
    var users = xml.ns::["return"].ax2427::user;
    var texts = xml.ns::["return"].ax2427::text;
    for (var i = 0; i < paths.length(); i++) {
        comments.push({
            path:paths[i].text().toString(),
            time:times[i].text().toString(),
            user:users[i].text().toString(),
            text:texts[i].text().toString()
        });
    }
    comments.sort(function (c1, c2) {
        return parseInt(c2.time, "10") - parseInt(c1.time, "10");
    });
    return {
        error:false,
        comments:comments
    };
}

function getAssociationsFunc(path,type) {
    var url = gregUrl + "services/WSRegistryService";
    var payload =
        <api:WSgetAssociations xmlns:api="http://api.ws.registry.carbon.wso2.org">
    <api:resourcePath>/_system/governance{path}</api:resourcePath>
    <api:associationType>{type}</api:associationType>
 </api:WSgetAssociations>;
    var result = invokeService(url, payload, "urn:WSgetAssociations", null);
    if (result.error) {
        log("Error getting the associations for resource " + path, "error");
        return {
            error:result.error,
            associations:null
        };
    }
    var xml = result.client.responseE4X;
    var ns = "http://api.ws.registry.carbon.wso2.org";
    var ax2430="http://api.ws.registry.carbon.wso2.org/xsd"
    var associations = [];
    var paths = xml.ns::["return"].ax2430::destinationPath;

    for (var i = 0; i < paths.length(); i++) {
    	associations.push({
            path:paths[i].text().toString()

        });
    }

    return {
        error:false,
        associations:associations
    };
}

function getReviewsFunc(path) {
    var reviews = [];
    var comments = getCommentsFunc(path);
    if (comments.error) {
        return {
            error:true,
            reviews:null
        };
    }
    comments = comments.comments;
    for (var i = 0; i < comments.length; i++) {
        var comment = comments[i];
        var rating = getRatingFunc(path, comment.user);
        reviews.push({
            path:comment.path,
            time:comment.time,
            user:comment.user,
            text:comment.text,
            rating:rating
        });
    }
    return {
        error:false,
        reviews:reviews
    };
}

function getResourceContentFunc(path) {
    var url = gregUrl + "services/ResourceAdminService.ResourceAdminServiceHttpsSoap11Endpoint/";
    // log(path);

    if (path.charAt(path.length - 1) == "/") {
        path = path.substring(0, path.length - 1);
    }

    var payload =
        <ser:getTextContent xmlns:ser="http://services.resource.registry.carbon.wso2.org">
            <ser:path>{path}</ser:path>
        </ser:getTextContent>

    var result = invokeService(url, payload, "urn:getTextContent", null);
    if (result.error) {
        log("Error while creating resource at " + path, "error");
        return {
            error:true
        };
    }

    var xml = result.client.responseE4X;
    var services = new Array();
    var ns = "http://services.resource.registry.carbon.wso2.org";
    var content = xml.ns::["return"][0].text().toString();
    // log("content"+content);
    var thumbURL = content.slice(content.indexOf('<thumbURL>'), content.indexOf('</thumbURL>')).replace('<thumbURL>', '');
    var author = content.slice(content.indexOf('<author>'), content.indexOf('</author>')).replace('<author>', '');
    var supportForumURL = content.slice(content.indexOf('<supportForumURL>'), content.indexOf('</supportForumURL>')).replace('<supportForumURL>', '');
    var description = content.slice(content.indexOf('<description>'), content.indexOf('</description>')).replace('<description>', '');
    var name = content.slice(content.indexOf('<name>'), content.indexOf('</name>')).replace('<name>', '');
    var version = content.slice(content.indexOf('<version>'), content.indexOf('</version>')).replace('<version>', '');
    var namespace = content.slice(content.indexOf('<namespace>'), content.indexOf('</namespace>')).replace('<namespace>', '');
    var wsdlURL = content.slice(content.indexOf('<wsdlURL>'), content.indexOf('</wsdlURL>')).replace('<wsdlURL>', '');

    return {
        error:false,
        ThumbURL:thumbURL,
        author:author,
        ThumbURL:thumbURL,
        description:description,
        name:name,
        version:version,
        namespace:namespace,
        wsdlURL:wsdlURL,
        supportForumURL:supportForumURL
    };
}

function getResourceTextContentFunc(path) {
    var url = gregUrl + "services/ResourceAdminService.ResourceAdminServiceHttpsSoap11Endpoint/";
  // log(path);

    if (path.charAt(path.length - 1) == "/") {
        path = path.substring(0, path.length - 1);
    }

    var payload =
        <ser:getTextContent xmlns:ser="http://services.resource.registry.carbon.wso2.org">
            <ser:path>{path}</ser:path>
        </ser:getTextContent>

    var result = invokeService(url, payload, "urn:getTextContent", null);
    if (result.error) {
        log("Error while creating resource at " + path, "error");
        return {
            error:true,
            result:null
        };
    }

    var xml = result.client.responseE4X;
   // var services = new Array();
    var ns = "http://services.resource.registry.carbon.wso2.org";
    var content = xml.ns::["return"][0].text().toString();
   // log(content)
    return {
        error:false,
        result:content
    };
}

function getDocContentFunc(path) {
	 var contentMain = getResourceTextContentFunc(path);
		var content = contentMain.result;
		var doc = new Array();
		var document = new Array();
		var doc = content.split('<documentation>');

		for(var i=1; i<doc.length ; i++){
			var title = doc[i].slice(doc[i].indexOf('<title>'), doc[i].indexOf('</title>')).replace('<title>', '');
			var describtion = doc[i].slice(doc[i].indexOf('<describtion>'), doc[i].indexOf('</describtion>')).replace('<describtion>', '');
			document.push({
				title:title,
				describtion:describtion

			});
		}
	  return {
	        error:false,
	        doc:document
	    };
}

function getAllDocContentFunc(path) {
	var doc = new Array();
	var document = new Array();
	var contentMain  = getAssociationsFunc(path,"docing");
		var content = contentMain.associations;
		// log(" :: " +content.length);
		for(var i=0; i<content.length ; i++){
		// log(i+" :: " +content[i].path);
			var documentationMain = getDocContentFunc(content[i].path);
			var documentation = documentationMain.doc;
		// log(" ::: " +documentation.length);
			for(var j=0; j<documentation.length ; j++){
				// log(j+" :: " +documentation[j].title);

				  var elem = {
			                title:documentation[j].title,
			                describtion:documentation[j].describtion
			            };
				  document.push(elem);
				}

		}
	  return {
	        error:false,
	        doc:document
	    };
}

function getAllSamplesContentFunc(path) {
	var doc = new Array();
	var samples = new Array();
	var contentMain  = getAssociationsFunc(path,"sample");
		var content = contentMain.associations;

		for(var i=0; i<content.length ; i++){

			var documentationMain = getSampleContentFunc(content[i].path);
			var documentation = documentationMain.samples;

			for(var j=0; j<documentation.length ; j++){


				  var elem = {
			                title:documentation[j].sampleTitle,
			                describtion:documentation[j].sampleDescribtion
			            };
				  samples.push(elem);
				}

		}
	  return {
	        error:false,
	        sample:samples
	    };
}


function getSampleContentFunc(path) {
	 var contentMain = getResourceTextContentFunc(path);
		var content = contentMain.result;
		var sampl = new Array();
		var samples = new Array();
		var sampl = content.split('<sample>');

		for(var i=1; i<sampl.length ; i++){
			var title = sampl[i].slice(sampl[i].indexOf('<title>'), sampl[i].indexOf('</title>')).replace('<title>', '');
			var describtion = sampl[i].slice(sampl[i].indexOf('<describtion>'), sampl[i].indexOf('</describtion>')).replace('<describtion>', '');
			samples.push({
				sampleTitle:title,
				sampleDescribtion:describtion

			});
		}
	  return {
	        error:false,
	        samples:samples
	    };
}

function getWSDL(path) {
    var url = gregUrl + "services/ResourceAdminService.ResourceAdminServiceHttpsSoap11Endpoint/";
    var action = "urn:getTextContent";
    var getPayload = function(path) {
        return <ser:getTextContent xmlns:ser="http://services.resource.registry.carbon.wso2.org">
                <ser:path>{path}</ser:path>
            </ser:getTextContent>;
    };
    if (path.charAt(path.length - 1) == "/") {
        path = path.substring(0, path.length - 1);
    }

    var payload = getPayload("/_system/governance" + path);

    var result = invokeService(url, payload, action, null);
    if (result.error) {
        log("Error while getting the resource at " + path, "error");
        return {
            error:true
        };
    }
    var xml = result.client.responseE4X;
    var ns0 = "http://services.resource.registry.carbon.wso2.org";
    var metaData = new XML(xml.ns0::["return"][0].text().toString());
    var ns1 = "http://www.wso2.org/governance/metadata";
    var wsdlURL = metaData.ns1::["interface"][0].ns1::wsdlURL.text().toString();
    payload = getPayload(wsdlURL);
    result = invokeService(url, payload, action, null);
    if (result.error) {
        log("Error while getting the resource at " + path, "error");
        return {
            error:true
        };
    }
    xml = result.client.responseE4X;
    return xml.ns0::["return"][0].text().toString();
}

function getDataJSON(result, successMsg, errorMsg) {
    if (result.error) {
        return {
            error:true,
            message:errorMsg,
            data:null
        };
    }
    var data = {};
    for (var key in result) {
        if (result.hasOwnProperty(key)) {
            if (key == "error") {
                continue;
            }
            data[key] = result[key];
        }
    }
    return {
        error:false,
        message:successMsg,
        data:data
    };
}



// calling Host Objects


// apistoreObj referring to Host Object Modular apistore
var apistoreObj= require('apistore');
var apiStore = new apistoreObj.APIStore();
var apiProvider = new apistoreObj.APIProvider();
/*
 * return a key of String params are apiname ,api version, subscriber for api
 * 
 */
function getKeyFunc(api, version, provider, context, application, username){

	var apiKey = apiStore.getKey(provider, api, version, context, application, username);

	return {
      error : false,
      key : apiKey
  };

}

function isSubscribedFunc(api, version, provider, username){
	var isSubscribed = apiStore.isSubscribed(provider, api, version, username);
	return {
      error : false,
      key : isSubscribed
  };

}

/*
 * return json of AllPublishedAPIs
 * 
 * 
 */
function getAllPublishedAPIsFunc(){
	var apis=  new Array();
	var apisout=  new Array();
	log("called getAllPublishedAPIs");	
	apis = apiStore.getAllPublishedAPIs();
	log("length" +apis.length);
	for (var k = 0; k < apis.length ; k++){
      var elem = {
      	name:apis[k].name,
      	provider:apis[k].provider,
      	version:apis[k].version,
      	description:apis[k].description,                         
      	rates:apis[k].rates,
      	purchased:"false",
      	context:apis[k].context,
      	thumbURL:apis[k].thumbnailurl
      };
      apisout.push(elem);

}
return {
  error:false,
  apis:apisout
};
	
}

/*
 * return json of API under TopRatedAPIs param limit: count of API to be return
 * 
 */
function getTopRatedAPIsFunc(limit){
	var apis=  new Array();
	var apisout=  new Array();
	log("called getTopRatedAPIsFunc");	
	apis = apiStore.getTopRatedAPIs(limit);
	log("length" +apis.length);
	for (var k = 0; k < apis.length ; k++){
      var elem = {
      	name:apis[k].name,
      	author:apis[k].provider,
      	path:"http:google.lk",
      	version:apis[k].version,
      	purchased:"false",
      	thumbURL:"https://lh4.ggpht.com/XBJs8jZYLojWg5AtOzW5IJz0bQUuuwGdD7yYqwSxyoAcmtdIz9XU5a1304h_ergZ-oc=w78"
      		
      };
      apisout.push(elem);

}
return {
  error:false,
  topRated:apisout
};
	
}
/*
 * return json of API under TopRatedAPIs param limit: count of API to be return
 * 
 */
function getRecentlyAddedAPIsFunc(limit){
	var apis=  new Array();
	var apisout=  new Array();
	log("called getRecentlyAddedAPIsFunc "+limit);	
	apis = apiStore.getRecentlyAddedAPIs(limit);
	// apis = apiStore.getTopRatedAPIs(limit);
	log("length" +apis.length);
	for (var k = 0; k < apis.length ; k++){
      var elem = {
      	name:apis[k].name,
      	author:apis[k].provider,
      	path:"http:google.lk",
      	version:apis[k].version,
      	purchased:"false",
      	thumbURL:"https://lh4.ggpht.com/XBJs8jZYLojWg5AtOzW5IJz0bQUuuwGdD7yYqwSxyoAcmtdIz9XU5a1304h_ergZ-oc=w78"
      };
      apisout.push(elem);

}
return {
  error:false,
  recentlyAdded:apisout
};
	
}


/*
 * return json with tag and it's Count
 * 
 * 
 */
function getAllTagsFunc(){
	var tags=  new Array();
	var tagsout=  new Array();
	tags = apiStore.getAllTags();	
	for (var k = 0; k < tags.length ; k++){
		var count =1;
		var toSave = true;
		for (var j = 0; j < tagsout.length ; j++){
			if(tagsout[j].name == tags[k].name){tagsout[j].count = parseFloat(tagsout[j].count) +1; 
			toSave = false;
			}
		}
		if(toSave){
      var elem = {
      	name:tags[k].name,
      	count:count
      };
      tagsout.push(elem);
		}
}
return {
  error:false,
  tagCloud:tagsout
};
	
}

function listProvidersNamesFunc(){
	var providers=  new Array();
	var providersout=  new Array();
	log("called listProvidersNamesFunc");
	providers = apiStore.ListProvidersNames();
	log("length" +providers.length);
	for (var k = 0; k < providers.length ; k++){
		providersout.push(providers[k]);

}
return {
  error:false,
  providers:providersout
};
	
}


function listApplicationsFunc(){
	var applications=  new Array();
	var applicationsout=  new Array();
	log("called listProvidersNamesFunc");
	applications = apiStore.ListApplications();
	log("length" +applications.length);
	for (var k = 0; k < applications.length ; k++){
		applicationsout.push(applications[k]);

}
return {
  error:false,
  application:applicationsout
};
	
}

function searchAPIFunc(searchString){
	var apis=  new Array();
	var apisout=  new Array();
	log("called searchAPI");	
	apis = apiStore.searchAPI(searchString);
	log("length" +apis.length);
	for (var k = 0; k < apis.length ; k++){
      var elem = {
      	name:apis[k].name,
      	provider:apis[k].provider,
      	version:apis[k].version,
      	description:apis[k].description,                         
      	rates:apis[k].rates,
      	purchased:"false",
      	thumbURL:apis[k].thumbnailurl
      };
      apisout.push(elem);

}
return {
  error:false,
  apis:apisout
};
	
}

function searchAPIbyTypeFunc(searchString,searchType){
	var apis=  new Array();
	var apisout=  new Array();
	log("called searchAPI Type");
	apis = apiStore.searchAPIbyType(searchString,searchType);
	log("length" +apis.length);
	for (var k = 0; k < apis.length ; k++){
      var elem = {
      	name:apis[k].name,
      	provider:apis[k].provider,
      	version:apis[k].version,
      	description:apis[k].description,
      	rates:apis[k].rates,
      	purchased:"false",
      	thumbURL:apis[k].thumbnailurl
      };
      apisout.push(elem);

}
return {
  error:false,
  apis:apisout
};

}

function getAPIsWithTagFunc(tagName){
	var apis=  new Array();
	var apisout=  new Array();
	log("called getAPIsWithTag");	
	apis = apiStore.getAPIsWithTag(tagName);
	log("length" +apis.length);
	for (var k = 0; k < apis.length ; k++){
		
      var elem = {
      	name:apis[k].name,
      	provider:apis[k].provider,
      	version:apis[k].version,
      	description:apis[k].description,                         
      	rates:apis[k].rates,
      	purchased:"false",
      	thumbURL:apis[k].thumbnailurl
      };
      apisout.push(elem);

}
return {
  error:false,
  apis:apisout
};
	
}


function getAllDocumentationFunc(providerName, apiName,version){
	var docs=  new Array();
	var docsout=  new Array();
	log("called get All Documentations");	
	docs = apiStore.getAllDocumentation(providerName, apiName,version);
	log("length" +docs.length);
	for (var k = 0; k < docs.length ; k++){
		log('docs[k].sourcetype '+docs[k].sourceType);
		if(docs[k].type != "samples"){
			var sourceUrl = "null";
			var sourceUrlIn = docs[k].sourceUrl;
			if(sourceUrlIn != null){				
				sourceUrl = docs[k].sourceUrl
				}
      var elem = {
    	title:docs[k].name,
    	describtion:docs[k].summary,
    	sourcetype:docs[k].sourceType,
    	sourceUrl:docs[k].sourceUrl,
      	doctype:docs[k].type                  
      	
      };
      docsout.push(elem);
		}
}
return {
  error:false,
  doc:docsout
};
	
}


function getAllSampleFunc(providerName, apiName,version){
	var docs=  new Array();
	var docsout=  new Array();
	log("called get All sample");	
	docs = apiStore.getAllDocumentation(providerName, apiName,version);
	log("length" +docs.length);
	for (var k = 0; k < docs.length ; k++){
		if(docs[k].type == "samples"){			
			var sourceUrl = "null";
			var sourceUrlIn = docs[k].sourceUrl;
			if(sourceUrlIn != null){				
				sourceUrl = docs[k].sourceUrl
				}
      var elem = {
    	title:docs[k].name,
    	describtion:docs[k].summary,
    	sourcetype:docs[k].sourcetype,
    	sourceUrl:sourceUrl,
      	doctype:docs[k].type                  
      	
      };
      docsout.push(elem);
	}
}
return {
  error:false,
  doc:docsout
};
	
}


function getAPICommentsFunc(providerName, apiName,version){
	var comments=  new Array();
	var commentsout=  new Array();
	log("called getAPICommentsFunc "+providerName+' '+apiName+' '+version+' '+comment);	
	comments = apiStore.getComments(providerName, apiName,version);
	for (var k = 0; k < comments.length ; k++){
      var elem = {
    	userName:comments[k].userName,
    	comment:comments[k].comment    
      };
      commentsout.push(elem);

}
return {
  error:false,
  comments:commentsout
};
	
}

function addAPICommentFunc(providerName, apiName,version,comment){
	var comments=  new Array();
	var commentsout=  new Array();
	log("called add Comments "+providerName+' '+apiName+' '+version+' '+comment);	
	apiStore.addComments(providerName, apiName,version,comment);
	
return {
  error:false,
  status:"Success"
};
	
}
function getAPIFunc(providerName, apiName,version){
	var api=  new Array();
	var apisout=  new Array();
	log("called getAPIFunc");	
	api = apiStore.getAPI(providerName, apiName, version, getUserFunc().username);
    var k=0;
	var elem = {
	      	name:api[k].name,
	      	provider:api[k].provider,
	      	version:api[k].version,
	      	description:api[k].description,                         
	      	rates:api[k].rates,
	      	purchased:"false",
	      	thumbURL:api[k].thumbnailurl
	      };
      apisout.push(elem);


return {
  error:false,
  api:apisout
};
}

function addSubscriptionFunc(providerName, apiName, version, tier, applicationId, userId) {
    var status = apiStore.addSubscription(providerName, apiName, version, tier, applicationId, userId);
    return {
        error:false,
        subscribed : status
    };
}

function removeSubscriberFunc(providerName, apiName, version, application, userId) {
    var status = apiStore.removeSubscriber(providerName, apiName, version, application, userId);
    return {
        error:false,
        subscribed : status
    };
}


function getDescriptionFunc(path) {

          var description = {
            versionNumber:'11',
            description:'ssss',
           /*
			 * parentPath:xml.ns::["return"].ax2430::parentPath.text().toString(),
			 * createdTime:xml.ns::["return"].ax2430::createdTime.text().toString(),
			 * authorUserName:xml.ns::["return"].ax2430::authorUserName.text().toString(),
			 * lastModified:xml.ns::["return"].ax2430::lastModified.text().toString(),
			 * lastUpdaterUserName:xml.ns::["return"].ax2430::lastUpdaterUserName.text().toString(),
			 * path:path, purchased:isPurchased(content.name), rating:rating,
			 * averageRating:avgRating, thumbURL:content.ThumbURL,
			 * author:content.author, description:content.description,
			 * name:content.name, version:content.version,
			 * namespace:content.namespace,
			 * supportForumURL:content.supportForumURL, wsdlURL:content.wsdlURL,
			 */
            mediaType:'html'
        };
        return {
            error:false,
            description:description
        };
    } 

function getAPIDescriptionFunc(name,apiVersion,provider) {
	var api=  new Array();
log ('getAPIDescriptionFunc' + name+' '+apiVersion+' '+provider);
api = apiStore.getAPI(provider, name, apiVersion, getUserFunc().username);
var k=0;
    var apidescription = {
      versionNumber:api[k].version,
      description:api[k].description,
      name:name,
      version:apiVersion,
      author:provider,
      rating:api[k].rates,
      averageRating:api[k].rates,
      purchased:"false",
      thumbURL:api[k].thumbnailurl,
      tier:api[k].tier,
      context:api[k].context,
      subscribed : api[k].subscribed,
     /*
		 * parentPath:xml.ns::["return"].ax2430::parentPath.text().toString(),
		 * createdTime:xml.ns::["return"].ax2430::createdTime.text().toString(),
		 * authorUserName:xml.ns::["return"].ax2430::authorUserName.text().toString(),
		 * lastModified:xml.ns::["return"].ax2430::lastModified.text().toString(),
		 * lastUpdaterUserName:xml.ns::["return"].ax2430::lastUpdaterUserName.text().toString(),
		 * path:path, purchased:isPurchased(content.name), rating:rating,
		 * averageRating:avgRating, thumbURL:content.ThumbURL,
		 * author:content.author, description:content.description,
		 * name:content.name, version:content.version,
		 * namespace:content.namespace, supportForumURL:content.supportForumURL,
		 * wsdlURL:content.wsdlURL,
		 */
      mediaType:'html'
  };
  return {
      error:false,
      description:apidescription
  };
}

function getAPIKeyFunc(providerName, apiName, version, apiContext, username, password, endurl, application) {
    var apikey = apiStore.getAPIKey(providerName, apiName, version, apiContext, username, password, endurl, application);
    return {
        error : false,
        key : apikey
    };
}

function getSubscriptionsFunc(providerName, apiName, version, username) {
    var subscriptions = apiStore.getSubscriptions(providerName, apiName, version, username);
    return {
        error : false,
        subscriptions : subscriptions
    };
}

function getAllSubscriptionsFunc(username) {
    var applications = apiStore.getAllSubscriptions(username);
    return {
        error : false,
        applications : applications
    };
}


function rateAPIFunc(providerName, apiName,version,rate) {
	var api=  new Array();
log ('xrateAPIFunc' + providerName+' '+apiName+' '+version+ ' '+ rate);
api = apiStore.rateAPI(providerName, apiName,version,rate);
var k=0;

var apidetails = {
		apiName:apiName,
        versionNumber:version,
        provider:providerName,
        rates:rate
  }
  return {
      error:false,
      api:apidetails
  };
}

function getInlineContentFunc(apiName, version,docName,apiProvider) {
    log("getInlineContentFunc " +apiName+'_'+version+"'"+ docName);
   
    var docOut = new Array();
    var doc = new Array();
    doc = apiStore.getInlineContent(apiProvider, apiName, version,docName);
    var k=0;
    	log('doc[k].content '+doc[k].content);
    	log(doc[k].content.length);
        var elem = {
        	apiProvider:providerName,
        	apiName:apiName,
        	apiVersion:version,
            docName:doc[k].docName,
            docContent:doc[k].content
        };
       
        docOut.push(elem);
    
    return {
        error:false,
        doc:docOut
    };

}


// end of calling Host objects


%>